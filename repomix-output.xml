This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
SelfPacedStudy-backend/
  .git/
    hooks/
      applypatch-msg.sample
      commit-msg.sample
      fsmonitor-watchman.sample
      post-update.sample
      pre-applypatch.sample
      pre-commit.sample
      pre-merge-commit.sample
      pre-push.sample
      pre-rebase.sample
      pre-receive.sample
      prepare-commit-msg.sample
      push-to-checkout.sample
      update.sample
    info/
      exclude
    logs/
      refs/
        heads/
          main
        remotes/
          origin/
            HEAD
      HEAD
    refs/
      heads/
        main
      remotes/
        origin/
          HEAD
    config
    description
    HEAD
    packed-refs
  src/
    controllers/
      chatController.ts
      difficultyController.ts
      transcriptController.ts
    routes/
      chatRouter.ts
      difficultyRoutes.ts
      transcriptRouter.ts
    services/
      chatService.ts
      difficultyModel.ts
      transcriptService.ts
    utils/
      BotMemoryManager.ts
      GetYoutubeTranscript.ts
      logger.ts
      modelConfig.ts
      pdfLoader.ts
      takeScreenshot.ts
    index.ts
  .env.example
  .eslintrc.json
  .gitignore
  install.sh
  LICENSE
  package.json
  README.md
  tsconfig.json
SelfPacedStudy-ui/
  .git/
    hooks/
      applypatch-msg.sample
      commit-msg.sample
      fsmonitor-watchman.sample
      post-update.sample
      pre-applypatch.sample
      pre-commit.sample
      pre-merge-commit.sample
      pre-push.sample
      pre-rebase.sample
      pre-receive.sample
      prepare-commit-msg.sample
      push-to-checkout.sample
      update.sample
    info/
      exclude
    logs/
      refs/
        heads/
          main
        remotes/
          origin/
            HEAD
      HEAD
    refs/
      heads/
        main
      remotes/
        origin/
          HEAD
    config
    description
    HEAD
    packed-refs
  public/
    next.svg
    privacy.html
    vercel.svg
  src/
    app/
      classroom/
        page.tsx
      experiment/
        page.tsx
      mlexperiment/
        page.tsx
      globals.css
      layout.tsx
      page.tsx
    components/
      chat/
        ChatBox.tsx
        ChatToolbar.tsx
        Message.tsx
      generic/
        AlertDialog.tsx
        CircularProgressWithLabel.tsx
        ClassroomToolbar.tsx
        CustomAlertModal.tsx
        CustomIconButton.tsx
        LinkTypography.tsx
        TitleTypography.tsx
      tum-bar/
        TumBar.tsx
      upload/
        components/
          DropzoneArea.tsx
          UploadedFile.tsx
          UploadTextField.tsx
        Upload.tsx
      video-player/
        VideoPlayer.tsx
    theme/
      theme.tsx
    utils/
      constants.tsx
      ParseLatex.tsx
      UseOutsideClickDetectorHook.tsx
  .env.example
  .eslintrc.json
  .gitignore
  Dockerfile
  LICENSE
  next.config.js
  package.json
  postcss.config.js
  README.md
  tailwind.config.ts
  tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="SelfPacedStudy-backend/.git/hooks/applypatch-msg.sample">
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:
</file>

<file path="SelfPacedStudy-backend/.git/hooks/commit-msg.sample">
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}
</file>

<file path="SelfPacedStudy-backend/.git/hooks/fsmonitor-watchman.sample">
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}
</file>

<file path="SelfPacedStudy-backend/.git/hooks/post-update.sample">
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info
</file>

<file path="SelfPacedStudy-backend/.git/hooks/pre-applypatch.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:
</file>

<file path="SelfPacedStudy-backend/.git/hooks/pre-commit.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --
</file>

<file path="SelfPacedStudy-backend/.git/hooks/pre-merge-commit.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:
</file>

<file path="SelfPacedStudy-backend/.git/hooks/pre-push.sample">
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0
</file>

<file path="SelfPacedStudy-backend/.git/hooks/pre-rebase.sample">
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END
</file>

<file path="SelfPacedStudy-backend/.git/hooks/pre-receive.sample">
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi
</file>

<file path="SelfPacedStudy-backend/.git/hooks/prepare-commit-msg.sample">
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi
</file>

<file path="SelfPacedStudy-backend/.git/hooks/push-to-checkout.sample">
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi
</file>

<file path="SelfPacedStudy-backend/.git/hooks/update.sample">
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0
</file>

<file path="SelfPacedStudy-backend/.git/info/exclude">
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</file>

<file path="SelfPacedStudy-backend/.git/logs/refs/heads/main">
0000000000000000000000000000000000000000 423e861dd02c7650d710a8e7ce46d9ed09a39bf8 Baronage Zhang <baronagezhang@MacBook-Pro-3.local> 1743497270 +0800	clone: from https://github.com/SelfPacedStudy-Orga/SelfPacedStudy-backend.git
</file>

<file path="SelfPacedStudy-backend/.git/logs/refs/remotes/origin/HEAD">
0000000000000000000000000000000000000000 423e861dd02c7650d710a8e7ce46d9ed09a39bf8 Baronage Zhang <baronagezhang@MacBook-Pro-3.local> 1743497270 +0800	clone: from https://github.com/SelfPacedStudy-Orga/SelfPacedStudy-backend.git
</file>

<file path="SelfPacedStudy-backend/.git/logs/HEAD">
0000000000000000000000000000000000000000 423e861dd02c7650d710a8e7ce46d9ed09a39bf8 Baronage Zhang <baronagezhang@MacBook-Pro-3.local> 1743497270 +0800	clone: from https://github.com/SelfPacedStudy-Orga/SelfPacedStudy-backend.git
</file>

<file path="SelfPacedStudy-backend/.git/refs/heads/main">
423e861dd02c7650d710a8e7ce46d9ed09a39bf8
</file>

<file path="SelfPacedStudy-backend/.git/refs/remotes/origin/HEAD">
ref: refs/remotes/origin/main
</file>

<file path="SelfPacedStudy-backend/.git/config">
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
	precomposeunicode = true
[remote "origin"]
	url = https://github.com/SelfPacedStudy-Orga/SelfPacedStudy-backend.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main
	vscode-merge-base = origin/main
	vscode-merge-base = origin/main
</file>

<file path="SelfPacedStudy-backend/.git/description">
Unnamed repository; edit this file 'description' to name the repository.
</file>

<file path="SelfPacedStudy-backend/.git/HEAD">
ref: refs/heads/main
</file>

<file path="SelfPacedStudy-backend/.git/packed-refs">
# pack-refs with: peeled fully-peeled sorted 
0679cfe685ea13ff77928bfcc112c2b59843c90e refs/remotes/origin/aws
f4d4ead90db74097eb10f0c5ecba145287b9ca23 refs/remotes/origin/change-screenshot
3d0c8025c0e9fa39df230618e20e25db14a49632 refs/remotes/origin/csv-to-pdf
60de92592e530383a5447611dc360ef61f1018fb refs/remotes/origin/hai_group_features
423e861dd02c7650d710a8e7ce46d9ed09a39bf8 refs/remotes/origin/main
85444dd470e31afdbb006a8de1d75f6797e47e1c refs/remotes/origin/style_toggle
</file>

<file path="SelfPacedStudy-backend/src/controllers/chatController.ts">
import { Request, Response } from 'express';
import {askQuestion, createPdfData, writeChatHistory} from '../services/chatService.js';
import { logger } from '../utils/logger.js';

/**
 * Asynchronously handles incoming chat messages.
 * 
 * @async
 * @function handleIncomingMessage
 * @param {Request} req - Express.js request object.
 * @param {Response} res - Express.js response object.
 * @returns {Promise<void>} - A Promise that resolves when the function has completed.
 * 
 * @throws Will throw an error if the message is not included in the request body.
 */
async function handleIncomingMessage(req: Request, res: Response): Promise<void> {
    try {

        const { message, videoPosition, userId } = req.body;

        const imageData = req.file ? req.file.buffer : undefined;

        if (!message) {
            res.status(400).json({ error: 'No message in the request' });
            return;
        }
        
        const timestamp = videoPosition * 1000;
        const result = await askQuestion(message, timestamp, userId, imageData);
        res.status(200).send({ result });

    } catch (error) {
        res.status(500).json({ error });
        logger.error(error);
    }
}

async function handleSave(req: Request, res: Response) {
    try {
        const userId = req.body.userId;
        await writeChatHistory(userId);
        res.status(200).json({ message: 'Chat history written successfully' });
    } catch (error) {
        res.status(500).json({ error });
        logger.error(error);
    }
}

async function handleReturnHistory(req: Request, res: Response) {
    try {
        const userId = req.body.userId;
        const pdfData = await createPdfData(userId);
        // Set the Content-Type header
        res.setHeader('Content-Type', 'application/pdf');
        pdfData.pipe(res);
    } catch (error) {
        res.status(500).json({ error });
        logger.error(error);
    }
}

export default {
    handleIncomingMessage,
    handleSave,
    handleReturnHistory
};
</file>

<file path="SelfPacedStudy-backend/src/controllers/difficultyController.ts">
// src/controllers/difficultyController.ts
import { Request, Response } from 'express';
import { calculateDifficulty } from '../services/difficultyModel';

// 处理获取难度评分的请求
export const getDifficultyScore = async (req: Request, res: Response): Promise<Response> => {
  try {
    const { transcript }: { transcript: string } = req.body;

    if (!transcript) {
      return res.status(400).json({ error: 'Transcript is required.' });
    }

    // 异步计算难度
    const score = await calculateDifficulty(transcript);

    return res.json({ score });
  } catch (error) {
    console.error('Error calculating difficulty:', error);
    return res.status(500).json({ error: 'Error processing the transcript.' });
  }
};
</file>

<file path="SelfPacedStudy-backend/src/controllers/transcriptController.ts">
/**
 * Asynchronously handles transcript processing of the video and slides.
 * 
 * @async
 * @function handleTranscript
 * @param {Request} req - Express.js request object.
 * @param {Response} res - Express.js response object.
 * @returns {Promise<void>} - A Promise that resolves when the function has completed.
 * 
 * @throws Will throw an error if the URL is not included in the request body.
 */
import { Request, Response } from 'express';
import transcriptService from "../services/transcriptService.js";
import { initializeContext } from "../services/chatService.js";

/**
 * Asynchronously handles transcript processing of the video and slides.
 * 
 * @async
 * @function handleTranscript
 * @param {Request} req - Express.js request object.
 * @param {Response} res - Express.js response object.
 * @returns {Promise<void>} - A Promise that resolves when the function has completed.
 * 
 * @throws Will throw an error if the URL is not included in the request body.
 */
async function handleTranscript(req: Request, res: Response): Promise<void> {
    try {
        let mergedPdfBuffer: Buffer | null = null;

        // Handle file transcript (if files are provided)
        if (req.files?.length !== 0) {
            console.log('Files uploaded successfully', req.files);
            const files = req.files as Express.Multer.File[];
            const pdfBuffers = files.map(file => file.buffer);
            mergedPdfBuffer = await transcriptService.mergeSlides(pdfBuffers); 
        }

        // Extract URL from the request
        const url = req.body.url;
        console.log('Extracted URL:', url);

        // Extract userId from the request
        const userId = req.body.userId;
        console.log('Extracted userId:', userId);

        // Handle URL transcript (if URL is provided)
        if (!url) {
            throw new Error('No URL provided');
        }

        const transcriptDocs = await transcriptService.getVideoTranscript(url);
        console.log('Transcript documents retrieved:', transcriptDocs);

        // Check if transcriptDocs is valid and has content
        if (!Array.isArray(transcriptDocs) || transcriptDocs.length === 0) {
            throw new Error('No transcript content found');
        }

        // Initialize the context for LLM with the transcript and slides for the specific user
        await initializeContext(mergedPdfBuffer, transcriptDocs, url, userId);

    } catch (error: unknown) {
        if (error instanceof Error) {
            console.error('Error message:', error.message);
            res.status(500).json({ message: "Error processing transcripts", error: error.message });
        } else {
            // If it's not an Error instance, you might not be able to get a message property
            console.error('An unexpected error occurred:', error);
            res.status(500).json({ message: "An unexpected error occurred" });
        }
    }
}

export default { handleTranscript };
</file>

<file path="SelfPacedStudy-backend/src/routes/chatRouter.ts">
import express from 'express';
import multer from 'multer';
import chatController from '../controllers/chatController.js';

const router = express.Router();
const storage = multer.memoryStorage(); // Stores files in memory
const upload = multer({ storage: storage });

// POST /chats
router.post(
    '/',
    upload.single('imageData'),
    chatController.handleIncomingMessage,
);

router.post(
    '/save',
    upload.none(),
    chatController.handleSave,
);

router.post(
    '/history',
    chatController.handleReturnHistory
);

export default router;
</file>

<file path="SelfPacedStudy-backend/src/routes/difficultyRoutes.ts">
// src/routes/difficultyRoute.ts
import express from 'express';
import { getDifficultyScore } from '../controllers/difficultyController';

const router = express.Router();

// 定义路由，处理 POST 请求获取难度评分
router.post('/difficulty', getDifficultyScore);

export default router;
</file>

<file path="SelfPacedStudy-backend/src/routes/transcriptRouter.ts">
import express from 'express';
import multer from 'multer';
import transcriptController from "../controllers/transcriptController.js";

const router = express.Router();
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

// POST /transcript
router.post(
    '/',
    upload.array('pdfs'),
    transcriptController.handleTranscript
);

export default router;
</file>

<file path="SelfPacedStudy-backend/src/services/chatService.ts">
import { formatDocumentsAsString } from "langchain/util/document";
import { HumanMessage } from "@langchain/core/messages";
import { BaseMessage } from "@langchain/core/messages";
import takeScreenshot from "../utils/takeScreenshot.js";
import { model } from "../utils/modelConfig.js";
import BotMemoryManager from "../utils/BotMemoryManager.js";
import fs from "fs";
import path from "path";
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import nodemailer from 'nodemailer';
import PDFDocument from 'pdfkit';
import { createObjectCsvStringifier } from 'csv-writer';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const SCREENSHOTS_OUTPUT_DIR = '../../screenshots';

/**
 * Function to serialize chat history into a string.
 * 
 * @param {BaseMessage[]} chatHistory - Array of chat messages.
 * @returns {string} - Serialized chat history.
 */
const serializeChatHistory = (chatHistory:BaseMessage[]): string => 
  chatHistory
    .map((chatMessage) => {
      if (chatMessage._getType() === "human") {
        return `Human: ${chatMessage.content}`;
      } else if (chatMessage._getType() === "ai") {
        return `Assistant: ${chatMessage.content}`;
      } else {
        return `${chatMessage.content}`;
      }
    })
    .join("\n");

/**
 * Function to initialize the bot's context.
 * 
 * @async
 * @param {Buffer|null} slides - Slides data.
 * @param {any} transcriptDocs - Transcript documents.
 */
async function initializeContext(slides: Buffer|null, transcriptDocs: any, url: string, userId: string) {
    await BotMemoryManager.setInstance(userId, slides, transcriptDocs, url);
}

/**
 * Function to ask a question to the bot.
 *
 * @async
 * @param {string} question - The question to ask.
 * @param {number} timestamp - The timestamp of the question.
 * @param userId - ID of the current user.
 * @param {Buffer} [imageData] - Optional image data.
 * @returns {Promise<string>} - The bot's response.
 * @throws Will throw an error if the call chain method fails to execute.
 */
async function askQuestion(question: string, timestamp: number,userId: string, imageData?: Buffer) {
    try {
      const sanitizedQuestion = question.trim().replace("\n", " "); // Remove newlines from the question

      const retriever = await BotMemoryManager.getRetrieverInstance(userId);
      const memory = BotMemoryManager.getMemoryInstance(userId);
      const transcriptRetriever = await BotMemoryManager.getTranscriptRetrieverInstance(userId);

      if ( memory && transcriptRetriever) { // If the bot's context has been initialized
        let startOffset = 0;
        if (timestamp > 3000) startOffset = timestamp - 3000;
        const stringWithTimestamp = `Before starting my question: Find between offsets ${startOffset} and ${timestamp + 30000}, and my question is: ` + sanitizedQuestion;
        const relevantDocsTranscript = await transcriptRetriever.getRelevantDocuments(stringWithTimestamp); // Get the relevant documents from the transcript
        const serializedTranscript = formatDocumentsAsString(relevantDocsTranscript); // Serialize the transcript documents

        // Load the bot's memory variables
        const savedMemory = await memory.loadMemoryVariables({});
        const hasHistory = savedMemory.chatHistory.length > 0;
        const chatHistory = hasHistory ? savedMemory.chatHistory : null;

        const chatHistoryString = chatHistory
        ? serializeChatHistory(chatHistory)
        : null;

        let prompt = "";

        if ( retriever !== null ) {
          const relevantDocs = await retriever.getRelevantDocuments(sanitizedQuestion);
          const serialized = formatDocumentsAsString(relevantDocs);

          prompt = 
            `The user is currently watching a lecture video and will ask you questions about the lecture and the lecture slides. 
            Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.
            ----------------
            CONTEXT OF VIDEO TRANSCRIPT: ${serializedTranscript}
            ----------------
            CONTEXT OF LECTURE SLIDES: ${serialized}
            ----------------
            CHAT HISTORY: ${chatHistoryString}
            ----------------
            QUESTION: ${question}
            ----------------
            Helpful Answer:`;
        }
        else {
          prompt = 
            `The user is currently watching a lecture video and will ask you questions about the lecture and the lecture slides. 
            Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.
            ----------------
            CONTEXT OF VIDEO TRANSCRIPT: ${serializedTranscript}
            ----------------
            CHAT HISTORY: ${chatHistoryString}
            ----------------
            QUESTION: ${question}
            ----------------
            Helpful Answer:`;
        }

        // Construct the message to send to the bot in GPT-4 vision format
        const message = new HumanMessage({
            content: [
                {
                    type: "text",
                    text: prompt
                },
            ],
        });

        // Add the image data to the message if it exists
        if (imageData) {
            const base64Image = imageData.toString('base64');
            (message.content as any[]).push({
              type: "image_url",
              image_url: {
                url: `data:image/png;base64,${base64Image}`
              }
            });
        }

        if ( question.includes("slide") ) {
          const url = BotMemoryManager.getUrl(userId);

          const filename = `slide-${timestamp}.png`;
          const screenshotPath = path.join(__dirname, SCREENSHOTS_OUTPUT_DIR, filename);

          await takeScreenshot(url, timestamp, screenshotPath);

          const screenshot = fs.readFileSync(screenshotPath);
          const base64Image = screenshot.toString('base64');

          (message.content as any[]).push({
            type: "image_url",
            image_url: {
              url: `data:image/png;base64,${base64Image}`
            }
          });

          // Delete the screenshot
          fs.unlinkSync(screenshotPath);
        }

        const response = await model.invoke([message]);

        // Save the bot's response to the context to be used in the next question
        await memory.saveContext(
            {
              question: question,
            },
            {
              text: response.content,
            }
          );

        if (imageData) {
          await BotMemoryManager.addHistory(userId, timestamp, question, response.content.toString(), imageData);
        }
        else {
          await BotMemoryManager.addHistory(userId,timestamp, question, response.content.toString());
        }

        return response.content;
      }
    } catch (error) {
        console.error(error);
        throw new Error("Call chain method failed to execute!!");
      }
}

async function writeChatHistory(userId: string) {
  try {
    const doc = await createPdfData(userId);
    const pdfPath = path.join(__dirname, 'chat_history.pdf');
    doc.pipe(fs.createWriteStream(pdfPath));
    
    const csvData = await createCsvData(userId);

    if (!csvData) {
      throw new Error("Failed to generate history data");
    }

    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
          user: process.env.EMAIL_ADDRESS,
          pass: process.env.EMAIL_PASSWORD
      }
    });

    const mailOptions = {
      from: process.env.EMAIL_ADDRESS,
      to: process.env.EMAIL_ADDRESS,
      subject: '1 New Chat!',
      text: 'Here is the chat history.',
      attachments: [
        {
          filename: 'chat_history.pdf',
          path: pdfPath
        },
        {
          filename: 'chat_history.csv',
          content: csvData
        }
      ]
    };

    transporter.sendMail(mailOptions, function(error, info){
      if (error) {
          console.log(error);
      } else {
          console.log('Email sent: ' + info.response);
          BotMemoryManager.deleteSession(userId);
      }
    });
    
  } catch (error) {
      console.error(error);
      throw new Error("Failed to retrieve context from memory.");
  }
}

async function createPdfData(userId: string) {
  try {
    const doc = new PDFDocument;
    const chatHistory = await BotMemoryManager.getHistory(userId);
    const videoUrl = BotMemoryManager.getUrl(userId);
    const slideUploaded = await BotMemoryManager.getRetrieverInstance(userId) !== null;

    doc.font('Helvetica-Bold').fontSize(12).text(`Video URL: ${videoUrl}`, {link: videoUrl});
    doc.font('Helvetica-Bold').fontSize(12).text('Slide uploaded: ', { continued: true });
    doc.font('Helvetica').text(slideUploaded ? "Yes" : "No");

    for (const message of chatHistory) {
      doc.moveDown();
      doc.font('Helvetica-Bold').fontSize(11).text(`Timestamp: ${message.timestamp}`, { width: 450 });

      doc.font('Helvetica-Bold').fontSize(11).text('Human message: ', { continued: true, width: 450});
      doc.font('Helvetica').fontSize(11).text(`${message.humanMessage}` , { width: 450 });
      const remainingPageHeight = doc.page.height - doc.y - doc.page.margins.bottom;

      if (message.imageData) {
        if (250 > remainingPageHeight) {
            doc.addPage();
        }
        doc.image(message.imageData, {
          height: 250,
          width: 500,
        });
        doc.y = doc.y + 250;
      }

      doc.font('Helvetica-Bold').fontSize(11).text('AI message: ', { continued: true, width: 450});
      doc.font('Helvetica').fontSize(11).text(`${message.aiMessage}`, { width: 450 });
    }

    doc.end();

    return doc;
  } catch (error) {
    console.error(error);
    throw new Error("Failed to retrieve context from memory.");
  }
}

 async function createCsvData(userId: string) : Promise<string | null> {
  const chatHistory = await BotMemoryManager.getHistory(userId);
  const writer = createObjectCsvStringifier({
        header: [
            {id: 'timestamp', title: 'TIMESTAMP'},
            {id: 'humanMessage', title: 'HUMAN MESSAGE'},
            {id: 'aiMessage', title: 'AI MESSAGE'},
        ]
    });

    let csvData = writer.getHeaderString();
    csvData += writer.stringifyRecords(chatHistory);

    return csvData;
 }

export { askQuestion, initializeContext, writeChatHistory, createPdfData};
</file>

<file path="SelfPacedStudy-backend/src/services/difficultyModel.ts">
// src/services/difficultyModel.ts
import natural from 'natural';  // 修改为正确的导入方式

// 定义 calculateDifficulty 函数
const calculateDifficulty = (text: string) => {
  const tokenizer = new natural.WordTokenizer();  // 使用 natural.WordTokenizer()
  const words = tokenizer.tokenize(text);
  const wordCount = words.length;
  const uniqueWords = new Set(words).size;
  const difficultyScore = (uniqueWords / wordCount) * 100;
  return { difficulty: difficultyScore.toFixed(2) };
};

export { calculateDifficulty };
</file>

<file path="SelfPacedStudy-backend/src/services/transcriptService.ts">
import {PDFDocument} from 'pdf-lib';
import { Document } from "@langchain/core/documents";
import {YoutubeGrabTool} from "../utils/GetYoutubeTranscript.js";

// Define the maximum time gap allowed between sentences in the same paragraph
const MAX_TIME_GAP = 30000; // In milliseconds

/**
 * Function to form paragraphs from the transcript.
 * 
 * @param {Object[]} transcript - Array of transcript items.
 * @returns {Document[]} - Array of Document objects representing paragraphs.
 */
const formParagraphs = (transcript: {text: string, duration: number, offset: number}[]) => {
    const paragraphs: Document[] = [];
    let currentParagraph: string[] = [];
    let lastOffset: number = 0;
    let firstOffset: number = 0;
    transcript.forEach((item) => {
        if (lastOffset - firstOffset > MAX_TIME_GAP) {
            // If the gap is too large, start a new paragraph
            //currentParagraph.unshift(`From ${firstOffset} milliseconds to ${lastOffset} milliseconds, the speaker says: `);
            paragraphs.push(new Document({
                pageContent: currentParagraph.join(' '),
                metadata: {offset: firstOffset, duration: lastOffset - firstOffset}
                })
            );
            currentParagraph = [];
            firstOffset = lastOffset;
        }
        currentParagraph.push(item.text);
        lastOffset = item.offset;
    });
    // Add the last paragraph if it's not empty
    if (currentParagraph.length > 0) {
        paragraphs.push(new Document({
            pageContent: currentParagraph.join(' '),
            metadata: {offset: firstOffset, duration: lastOffset - firstOffset}
            })
        );
    }
    
    return paragraphs;
}

/**
 * Asynchronous function to get the video transcript. It uses Youtube's API to fetch the transcript.
 * 
 * @async
 * @param {string} url - The URL of the video.
 * @returns {Promise<Document[]>} - A Promise that resolves to an array of Document objects representing paragraphs.
 * @throws Will throw an error if the transcript cannot be fetched or written.
 */
async function getVideoTranscript(url: string): Promise<Document[]> {

    try {
        const transcript = await  YoutubeGrabTool.fetchTranscript(url);
        if (!Array.isArray(transcript) || transcript.length === 0) {
            throw new Error('No transcript documents found');
        }
        
        return formParagraphs(transcript);

    } catch(error) {
        console.error('Error fetching or writing youtube video transcript!');
        throw error;
    }
}

/**
 * Asynchronous function to merge slides.
 * 
 * @async
 * @param {Buffer[]} pdfBuffers - Array of Buffer objects representing PDFs.
 * @returns {Promise<Buffer>} - A Promise that resolves to a Buffer object representing the merged PDF.
 */
async function mergeSlides(pdfBuffers: Buffer[]): Promise<Buffer> {
    const mergedPdf = await PDFDocument.create();

    for (const pdfBuffer of pdfBuffers) {
        const pdf = await PDFDocument.load(pdfBuffer);
        const copiedPages = await mergedPdf.copyPages(pdf, pdf.getPageIndices());
        copiedPages.forEach(page => mergedPdf.addPage(page));
    }

    const mergedPdfBytes = await mergedPdf.save();
    return Buffer.from(mergedPdfBytes);
}

export default {
    getVideoTranscript,
    mergeSlides
}
</file>

<file path="SelfPacedStudy-backend/src/utils/BotMemoryManager.ts">
import { HNSWLib } from "@langchain/community/vectorstores/hnswlib";
import { OpenAIEmbeddings, OpenAI } from "@langchain/openai";
import { VectorStoreRetriever } from "@langchain/core/vectorstores";
import { getChunkedDocsFromPDF } from "./pdfLoader.js";
import { BufferMemory } from "langchain/memory";
import { Document } from "@langchain/core/documents";
import { MemoryVectorStore } from "langchain/vectorstores/memory";
import { SelfQueryRetriever } from "langchain/retrievers/self_query";
import { FunctionalTranslator } from "langchain/retrievers/self_query/functional";
import { AttributeInfo } from "langchain/schema/query_constructor";
import { VectorStore } from "@langchain/core/vectorstores";

/**
 * We define the attributes we want to be able to query on.
 * in this case, we want to be able to query on the genre, year, director, rating, and length of the movie.
 * We also provide a description of each attribute and the type of the attribute.
 * This is used to generate the query prompts.
 */
const attributeInfo: AttributeInfo[] = [
  {
    name: "offset",
    description: "The timestamp in milliseconds of the start of the sentence",
    type: "number",
  },
  {
    name: "duration",
    description: "The duration of the sentence in milliseconds",
    type: "number",
  },
];

class BotMemoryManager {
  private static userSessions: Map<string, UserSession> = new Map();

  /**
   * Retrieves or initializes a session for a given userId.
   */
  private static getSessionForUser(userId: string): UserSession {
    if (!this.userSessions.has(userId)) {
      const newUserSession = new UserSession();
      this.userSessions.set(userId, newUserSession);
      return newUserSession;
    }
    return <UserSession>this.userSessions.get(userId);
  }

  /**
   * Deletes a session for a given userId.
   * @param {string} userId - The userId whose session needs to be deleted.
   * @returns {boolean} - Returns true if the session was successfully deleted, false if no session was found.
   */
  public static deleteSession(userId: string): boolean {
    if (this.userSessions.has(userId)) {
      this.userSessions.delete(userId);
      console.log(`Session for userId ${userId} has been deleted.`);
      return true;
    } else {
      console.log(`No session found for userId ${userId}.`);
      return false;
    }
  }

  public static async setInstance(userId: string, slides: Buffer | null, transcriptDocs: Document[], url: string): Promise<void> {
    const session = this.getSessionForUser(userId);
    await session.setInstance(slides, transcriptDocs, url);
  }

  public static async addHistory(userId: string, timestamp: number, humanMessage: string, aiMessage: string, imageData?: Buffer): Promise<void> {
    const session = this.getSessionForUser(userId);
    session.addHistory(timestamp, humanMessage, aiMessage, imageData);
  }

  public static async getRetrieverInstance(userId: string): Promise<VectorStoreRetriever<HNSWLib> | null> {
    const session = this.getSessionForUser(userId);
    return session.getRetrieverInstance();
  }

  public static getMemoryInstance(userId: string): BufferMemory | null {
    const session = this.getSessionForUser(userId);
    return session.getMemoryInstance();
  }

  public static async getTranscriptRetrieverInstance(userId: string): Promise<SelfQueryRetriever<VectorStore> | null> {
    const session = this.getSessionForUser(userId);
    return session.getTranscriptRetrieverInstance();
  }

  public static getUrl(userId: string): string {
    const session = this.getSessionForUser(userId);
    return session.getUrl();
  }

  public static async getHistory(userId: string): Promise<{ timestamp: number; humanMessage: string; aiMessage: string, imageData?: Buffer;}[]> {
    const session = this.getSessionForUser(userId);
    return session.getHistory();
  }
}

class UserSession {
  private retriever: VectorStoreRetriever<HNSWLib> | null = null;
  private memory: BufferMemory | null = null;
  private transcriptRetriever: SelfQueryRetriever<VectorStore> | null = null;
  private url: string = "";
  private history: { timestamp: number; humanMessage: string; aiMessage: string; imageData?: Buffer; }[] = [];

  public async setInstance(slides: Buffer | null, transcriptDocs: Document[], url: string ): Promise<void> {
    if (slides !== null) {
      const docs = await getChunkedDocsFromPDF(slides);
      const vectorStoreSlides = await HNSWLib.fromDocuments(docs, new OpenAIEmbeddings());
      this.retriever = vectorStoreSlides.asRetriever();
    }

    this.url = url;

    this.memory = new BufferMemory({
      memoryKey: "chatHistory",
      inputKey: "question", // The key for the input to the chain
      outputKey: "text", // The key for the final conversational output of the chain
      returnMessages: true,
    });

    const llm = new OpenAI();
    const documentContents = "Transcript of the lecture video";
    const vectorStoreTranscript = await MemoryVectorStore.fromDocuments(transcriptDocs, new OpenAIEmbeddings());
    this.transcriptRetriever = await SelfQueryRetriever.fromLLM({
      llm,
      vectorStore: vectorStoreTranscript,
      documentContents,
      attributeInfo,
      structuredQueryTranslator: new FunctionalTranslator(),
    });
  }

  public async addHistory(timestamp: number, humanMessage: string, aiMessage: string, imageData?: Buffer): Promise<void> {
    if (imageData) {
      this.history.push({ timestamp, humanMessage, aiMessage, imageData});
    }
    else {
      this.history.push({ timestamp, humanMessage, aiMessage });
    }
  }

  public getRetrieverInstance(): VectorStoreRetriever<HNSWLib> | null {
    return this.retriever;
  }

  public getMemoryInstance(): BufferMemory | null {
    return this.memory;
  }

  public getTranscriptRetrieverInstance(): SelfQueryRetriever<VectorStore> | null {
    return this.transcriptRetriever;
  }

  public getUrl(): string {
    return this.url;
  }

  public async getHistory(): Promise<{ timestamp: number; humanMessage: string; aiMessage: string; imageData?: Buffer }[]> {
    return this.history;
  }
}

export default BotMemoryManager;
</file>

<file path="SelfPacedStudy-backend/src/utils/GetYoutubeTranscript.ts">
import { parse } from "node-html-parser"
const RE_YOUTUBE =
    /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i
const USER_AGENT =
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36,gzip(gfe)"

class YoutubeTranscriptError extends Error {
    constructor(message: string) {
        super(`[YoutubeTranscript] ${message}`)
    }
}

type YtFetchConfig = {
    lang?: string // Object with lang param (eg: en, es, hk, uk) format.
}

/**
 * Class to retrieve transcript if exist
 */
class YoutubeGrabTool {
    /**
     * Fetch transcript from YTB Video
     * @param videoId Video url or video identifier
     * @param config Object with lang param (eg: en, es, hk, uk) format.
     * Will just the grab first caption if it can find one, so no special lang caption support.
     */
    static async fetchTranscript(videoId: string, config: YtFetchConfig = {}) {
        const identifier = this.retrieveVideoId(videoId)
        const lang = config?.lang ?? "en"
        try {
            const transcriptUrl = await fetch(
                `https://www.youtube.com/watch?v=${identifier}`,
                {
                    headers: {
                        "User-Agent": USER_AGENT,
                    },
                }
            )
                .then((res) => res.text())
                .then((html) => parse(html))
                .then((html) => this.#parseTranscriptEndpoint(html, lang))

            if (!transcriptUrl)
                throw new Error("Failed to locate a transcript for this video!")

            // Result is hopefully some XML.
            const transcriptXML = await fetch(transcriptUrl)
                .then((res) => res.text())
                .then((xml) => parse(xml))

            const chunks = transcriptXML.getElementsByTagName("text")

            function convertToMs(text: string) {
                const float = parseFloat(text.split("=")[1].replace(/"/g, "")) * 1000
                return Math.round(float)
            }

            const transcriptions = []
            for (const chunk of chunks) {
                const [offset, duration] = chunk.rawAttrs.split(" ")
                transcriptions.push({
                    text: chunk.text,
                    offset: convertToMs(offset),
                    duration: convertToMs(duration),
                })
            }
            return transcriptions
        } catch (e: any) {
            throw new YoutubeTranscriptError(e)
        }
    }

    static #parseTranscriptEndpoint(document: any, langCode?: string) {
        try {
            // Get all script tags on document page
            const scripts = document.getElementsByTagName("script")

            // find the player data script.
            const playerScript = scripts.find((script: any) =>
                script.textContent.includes("var ytInitialPlayerResponse = {")
            )

            const dataString =
                playerScript.textContent
                    ?.split("var ytInitialPlayerResponse = ")?.[1] //get the start of the object {....
                    ?.split("};")?.[0] + // chunk off any code after object closure.
                "}" // add back that curly brace we just cut.

            const data = JSON.parse(dataString.trim()) // Attempt a JSON parse
            const availableCaptions =
                data?.captions?.playerCaptionsTracklistRenderer?.captionTracks || []

            // If languageCode was specified then search for it's code, otherwise get the first.
            let captionTrack = availableCaptions?.[0]
            if (langCode)
                captionTrack =
                    availableCaptions.find((track: any) =>
                        track.languageCode.includes(langCode)
                    ) ?? availableCaptions?.[0]

            return captionTrack?.baseUrl
        } catch (e: any) {
            console.error(`YoutubeTranscript.#parseTranscriptEndpoint ${e.message}`)
            return null
        }
    }

    /**
     * Retrieve video id from url or string
     * @param videoId video url or video id
     */
    static retrieveVideoId(videoId: string) {
        if (videoId.length === 11) {
            return videoId
        }
        const matchId = videoId.match(RE_YOUTUBE)
        if (matchId && matchId.length) {
            return matchId[1]
        }
        throw new YoutubeTranscriptError("Impossible to retrieve Youtube video ID.")
    }
}

export { YoutubeGrabTool, YoutubeTranscriptError }
</file>

<file path="SelfPacedStudy-backend/src/utils/logger.ts">
import { format, transports, createLogger } from 'winston';

const customFormat = format.printf(({ level, message, timestamp }) => {
  const formattedMessage = message instanceof Object ? JSON.stringify(message, null, 2) : message;
  return `[${timestamp}] [${level}]: ${formattedMessage}`;
});

const logger = createLogger({
  format: format.combine(format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }), customFormat),
  transports: [new transports.Console()],
});

export { logger };
</file>

<file path="SelfPacedStudy-backend/src/utils/modelConfig.ts">
import { ChatOpenAI } from "@langchain/openai";

const OPENAI_API_KEY = process.env.OPENAI_API_KEY || '';

export const model = new ChatOpenAI({
    modelName: 'gpt-4-vision-preview',
    temperature: 0.9,
    openAIApiKey: OPENAI_API_KEY,
    maxTokens: 1000,
    streaming: true,
  });
</file>

<file path="SelfPacedStudy-backend/src/utils/pdfLoader.ts">
import { PDFLoader } from "langchain/document_loaders/fs/pdf";
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";
import { Blob } from 'fetch-blob';

/** 
  * Function to get chunked documents from a PDF buffer.
  * 
  * @async
  * @param {Buffer} buffer - The PDF buffer.
  * @returns {Promise<Document[]>} - The chunked documents.
  * @throws Will throw an error if the call chain method fails to execute.
  */
export async function getChunkedDocsFromPDF(buffer: Buffer) {
  try {
    const blob = new Blob([buffer]);
    const loader = new PDFLoader(blob);
    const docs = await loader.load();

    const textSplitter = new RecursiveCharacterTextSplitter({
      chunkSize: 1000,
      chunkOverlap: 200,
    });

    const chunkedDocs = await textSplitter.splitDocuments(docs);

    return chunkedDocs;
  } catch (e) {
    console.error(e);
    throw new Error("PDF docs chunking failed !");
  }
}
</file>

<file path="SelfPacedStudy-backend/src/utils/takeScreenshot.ts">
import ytdl from 'ytdl-core';
import ffmpeg from 'fluent-ffmpeg'
import { promisify } from 'util';


const screenshot = promisify((stream: any, time: string, outputPath: string, callback: any) => {
    ffmpeg(stream)
        .on('end', function()
        {
            callback(null, 'Screenshot taken');
        })
        .on('error', function(err)
        {
            callback(err);
        })
        .outputOptions(['-f image2', '-vframes 1', '-vcodec png', '-f rawvideo', '-ss ' + time])
        .output(outputPath)
        .run();
});

function millisecondsToTimeFormat(milliseconds: number): string {
    const pad = (num: number, size: number) => ('000' + num).slice(size * -1);
    const timeInSeconds = milliseconds / 1000;
    const time = parseFloat(timeInSeconds.toFixed(3));
    const hours = Math.floor(time / 60 / 60);
    const minutes = Math.floor(time / 60) % 60;
    const secs = Math.floor(time - minutes * 60);

    return pad(hours, 2) + ':' + pad(minutes, 2) + ':' + pad(secs, 2);
}

async function getVideoDuration(url: string): Promise<number> {
    const info = await ytdl.getInfo(url);
    const duration = parseInt(info.videoDetails.lengthSeconds);
    return duration;
}

async function takeScreenshot(videoUrl: string, timestampInMilliseconds: number, outputPath: string): Promise<any> {
        const durationInSeconds = await getVideoDuration(videoUrl);
        const timestampInSeconds = timestampInMilliseconds / 1000;

        console.log("Duration in seconds: ", durationInSeconds);
        console.log("Timestamp in seconds: ", timestampInSeconds);
        
        if (timestampInSeconds > durationInSeconds) {
            throw new Error('Requested timestamp is beyond the video duration.');
        }

        const timeFormat = millisecondsToTimeFormat(timestampInMilliseconds);
        console.log("Time format: ", timeFormat);
        const videoStream = ytdl(videoUrl, { quality: 'highest' });
        await screenshot(videoStream, timeFormat, outputPath);
}

export default takeScreenshot;
</file>

<file path="SelfPacedStudy-backend/src/index.ts">
import express from 'express';
import bodyParser from 'body-parser';
import cors from 'cors';
import multer from 'multer';
import { logger } from './utils/logger.js';
import transcriptRouter from "./routes/transcriptRouter.js";
import chatRouter from './routes/chatRouter.js';
import difficultyRoute from './routes/difficultyRoutes.js';
import 'dotenv/config';  // 确保加载 .env 文件


const PORT = process.env.PORT || 3000;
const app = express();

// 设置 multer 存储配置
const storage = multer.memoryStorage(); // 将文件存储在内存中
const upload = multer({ storage: storage });

app.use(bodyParser.json());
app.use(cors());

// 注册路由
app.use('/transcript', transcriptRouter);
app.use('/chats', chatRouter);
app.use('/api', difficultyRoute);

// 处理文件上传的路由
app.post('/difficulty/evaluate', upload.none(), (req, res) => {
    console.log('Received POST request at /difficulty/evaluate');
    console.log('Request body:', req.body);
    console.log('Files:', req.files);
    // 其他处理逻辑
  });
  

// 启动服务器
app.listen(PORT, () => {
    logger.info(`Server running at port: ${PORT}`);
});
</file>

<file path="SelfPacedStudy-backend/.env.example">
PORT=
OPENAI_API_KEY=
EMAIL_ADDRESS=
EMAIL_PASSWORD=
NOTIFICATION_EMAIL_ADDRESS=
</file>

<file path="SelfPacedStudy-backend/.eslintrc.json">
{
  "parser": "@typescript-eslint/parser",
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parserOptions": {
    "ecmaVersion": 2020,
    "sourceType": "module"
  },
  "env": {
    "node": true
  },
  "rules": {
    "@typescript-eslint/no-explicit-any": "off",
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-empty-function": "error"
  }
}
</file>

<file path="SelfPacedStudy-backend/.gitignore">
.idea
node_modules/
build/
.env
</file>

<file path="SelfPacedStudy-backend/install.sh">
#!/usr/bin/env bash

{ # this ensures the entire script is downloaded #

nvm_has() {
  type "$1" > /dev/null 2>&1
}

nvm_echo() {
  command printf %s\\n "$*" 2>/dev/null
}

if [ -z "${BASH_VERSION}" ] || [ -n "${ZSH_VERSION}" ]; then
  # shellcheck disable=SC2016
  nvm_echo >&2 'Error: the install instructions explicitly say to pipe the install script to `bash`; please follow them'
  exit 1
fi

nvm_grep() {
  GREP_OPTIONS='' command grep "$@"
}

nvm_default_install_dir() {
  [ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm"
}

nvm_install_dir() {
  if [ -n "$NVM_DIR" ]; then
    printf %s "${NVM_DIR}"
  else
    nvm_default_install_dir
  fi
}

nvm_latest_version() {
  nvm_echo "v0.39.4"
}

nvm_profile_is_bash_or_zsh() {
  local TEST_PROFILE
  TEST_PROFILE="${1-}"
  case "${TEST_PROFILE-}" in
    *"/.bashrc" | *"/.bash_profile" | *"/.zshrc" | *"/.zprofile")
      return
    ;;
    *)
      return 1
    ;;
  esac
}

#
# Outputs the location to NVM depending on:
# * The availability of $NVM_SOURCE
# * The method used ("script" or "git" in the script, defaults to "git")
# NVM_SOURCE always takes precedence unless the method is "script-nvm-exec"
#
nvm_source() {
  local NVM_GITHUB_REPO
  NVM_GITHUB_REPO="${NVM_INSTALL_GITHUB_REPO:-nvm-sh/nvm}"
  local NVM_VERSION
  NVM_VERSION="${NVM_INSTALL_VERSION:-$(nvm_latest_version)}"
  local NVM_METHOD
  NVM_METHOD="$1"
  local NVM_SOURCE_URL
  NVM_SOURCE_URL="$NVM_SOURCE"
  if [ "_$NVM_METHOD" = "_script-nvm-exec" ]; then
    NVM_SOURCE_URL="https://raw.githubusercontent.com/${NVM_GITHUB_REPO}/${NVM_VERSION}/nvm-exec"
  elif [ "_$NVM_METHOD" = "_script-nvm-bash-completion" ]; then
    NVM_SOURCE_URL="https://raw.githubusercontent.com/${NVM_GITHUB_REPO}/${NVM_VERSION}/bash_completion"
  elif [ -z "$NVM_SOURCE_URL" ]; then
    if [ "_$NVM_METHOD" = "_script" ]; then
      NVM_SOURCE_URL="https://raw.githubusercontent.com/${NVM_GITHUB_REPO}/${NVM_VERSION}/nvm.sh"
    elif [ "_$NVM_METHOD" = "_git" ] || [ -z "$NVM_METHOD" ]; then
      NVM_SOURCE_URL="https://github.com/${NVM_GITHUB_REPO}.git"
    else
      nvm_echo >&2 "Unexpected value \"$NVM_METHOD\" for \$NVM_METHOD"
      return 1
    fi
  fi
  nvm_echo "$NVM_SOURCE_URL"
}

#
# Node.js version to install
#
nvm_node_version() {
  nvm_echo "$NODE_VERSION"
}

nvm_download() {
  if nvm_has "curl"; then
    curl --fail --compressed -q "$@"
  elif nvm_has "wget"; then
    # Emulate curl with wget
    ARGS=$(nvm_echo "$@" | command sed -e 's/--progress-bar /--progress=bar /' \
                            -e 's/--compressed //' \
                            -e 's/--fail //' \
                            -e 's/-L //' \
                            -e 's/-I /--server-response /' \
                            -e 's/-s /-q /' \
                            -e 's/-sS /-nv /' \
                            -e 's/-o /-O /' \
                            -e 's/-C - /-c /')
    # shellcheck disable=SC2086
    eval wget $ARGS
  fi
}

install_nvm_from_git() {
  local INSTALL_DIR
  INSTALL_DIR="$(nvm_install_dir)"
  local NVM_VERSION
  NVM_VERSION="${NVM_INSTALL_VERSION:-$(nvm_latest_version)}"
  if [ -n "${NVM_INSTALL_VERSION:-}" ]; then
    # Check if version is an existing ref
    if command git ls-remote "$(nvm_source "git")" "$NVM_VERSION" | nvm_grep -q "$NVM_VERSION" ; then
      :
    # Check if version is an existing changeset
    elif ! nvm_download -o /dev/null "$(nvm_source "script-nvm-exec")"; then
      nvm_echo >&2 "Failed to find '$NVM_VERSION' version."
      exit 1
    fi
  fi

  local fetch_error
  if [ -d "$INSTALL_DIR/.git" ]; then
    # Updating repo
    nvm_echo "=> nvm is already installed in $INSTALL_DIR, trying to update using git"
    command printf '\r=> '
    fetch_error="Failed to update nvm with $NVM_VERSION, run 'git fetch' in $INSTALL_DIR yourself."
  else
    fetch_error="Failed to fetch origin with $NVM_VERSION. Please report this!"
    nvm_echo "=> Downloading nvm from git to '$INSTALL_DIR'"
    command printf '\r=> '
    mkdir -p "${INSTALL_DIR}"
    if [ "$(ls -A "${INSTALL_DIR}")" ]; then
      # Initializing repo
      command git init "${INSTALL_DIR}" || {
        nvm_echo >&2 'Failed to initialize nvm repo. Please report this!'
        exit 2
      }
      command git --git-dir="${INSTALL_DIR}/.git" remote add origin "$(nvm_source)" 2> /dev/null \
        || command git --git-dir="${INSTALL_DIR}/.git" remote set-url origin "$(nvm_source)" || {
        nvm_echo >&2 'Failed to add remote "origin" (or set the URL). Please report this!'
        exit 2
      }
    else
      # Cloning repo
      command git clone "$(nvm_source)" --depth=1 "${INSTALL_DIR}" || {
        nvm_echo >&2 'Failed to clone nvm repo. Please report this!'
        exit 2
      }
    fi
  fi
  # Try to fetch tag
  if command git --git-dir="$INSTALL_DIR"/.git --work-tree="$INSTALL_DIR" fetch origin tag "$NVM_VERSION" --depth=1 2>/dev/null; then
    :
  # Fetch given version
  elif ! command git --git-dir="$INSTALL_DIR"/.git --work-tree="$INSTALL_DIR" fetch origin "$NVM_VERSION" --depth=1; then
    nvm_echo >&2 "$fetch_error"
    exit 1
  fi
  command git -c advice.detachedHead=false --git-dir="$INSTALL_DIR"/.git --work-tree="$INSTALL_DIR" checkout -f --quiet FETCH_HEAD || {
    nvm_echo >&2 "Failed to checkout the given version $NVM_VERSION. Please report this!"
    exit 2
  }
  if [ -n "$(command git --git-dir="$INSTALL_DIR"/.git --work-tree="$INSTALL_DIR" show-ref refs/heads/master)" ]; then
    if command git --no-pager --git-dir="$INSTALL_DIR"/.git --work-tree="$INSTALL_DIR" branch --quiet 2>/dev/null; then
      command git --no-pager --git-dir="$INSTALL_DIR"/.git --work-tree="$INSTALL_DIR" branch --quiet -D master >/dev/null 2>&1
    else
      nvm_echo >&2 "Your version of git is out of date. Please update it!"
      command git --no-pager --git-dir="$INSTALL_DIR"/.git --work-tree="$INSTALL_DIR" branch -D master >/dev/null 2>&1
    fi
  fi

  nvm_echo "=> Compressing and cleaning up git repository"
  if ! command git --git-dir="$INSTALL_DIR"/.git --work-tree="$INSTALL_DIR" reflog expire --expire=now --all; then
    nvm_echo >&2 "Your version of git is out of date. Please update it!"
  fi
  if ! command git --git-dir="$INSTALL_DIR"/.git --work-tree="$INSTALL_DIR" gc --auto --aggressive --prune=now ; then
    nvm_echo >&2 "Your version of git is out of date. Please update it!"
  fi
  return
}

#
# Automatically install Node.js
#
nvm_install_node() {
  local NODE_VERSION_LOCAL
  NODE_VERSION_LOCAL="$(nvm_node_version)"

  if [ -z "$NODE_VERSION_LOCAL" ]; then
    return 0
  fi

  nvm_echo "=> Installing Node.js version $NODE_VERSION_LOCAL"
  nvm install "$NODE_VERSION_LOCAL"
  local CURRENT_NVM_NODE

  CURRENT_NVM_NODE="$(nvm_version current)"
  if [ "$(nvm_version "$NODE_VERSION_LOCAL")" == "$CURRENT_NVM_NODE" ]; then
    nvm_echo "=> Node.js version $NODE_VERSION_LOCAL has been successfully installed"
  else
    nvm_echo >&2 "Failed to install Node.js $NODE_VERSION_LOCAL"
  fi
}

install_nvm_as_script() {
  local INSTALL_DIR
  INSTALL_DIR="$(nvm_install_dir)"
  local NVM_SOURCE_LOCAL
  NVM_SOURCE_LOCAL="$(nvm_source script)"
  local NVM_EXEC_SOURCE
  NVM_EXEC_SOURCE="$(nvm_source script-nvm-exec)"
  local NVM_BASH_COMPLETION_SOURCE
  NVM_BASH_COMPLETION_SOURCE="$(nvm_source script-nvm-bash-completion)"

  # Downloading to $INSTALL_DIR
  mkdir -p "$INSTALL_DIR"
  if [ -f "$INSTALL_DIR/nvm.sh" ]; then
    nvm_echo "=> nvm is already installed in $INSTALL_DIR, trying to update the script"
  else
    nvm_echo "=> Downloading nvm as script to '$INSTALL_DIR'"
  fi
  nvm_download -s "$NVM_SOURCE_LOCAL" -o "$INSTALL_DIR/nvm.sh" || {
    nvm_echo >&2 "Failed to download '$NVM_SOURCE_LOCAL'"
    return 1
  } &
  nvm_download -s "$NVM_EXEC_SOURCE" -o "$INSTALL_DIR/nvm-exec" || {
    nvm_echo >&2 "Failed to download '$NVM_EXEC_SOURCE'"
    return 2
  } &
  nvm_download -s "$NVM_BASH_COMPLETION_SOURCE" -o "$INSTALL_DIR/bash_completion" || {
    nvm_echo >&2 "Failed to download '$NVM_BASH_COMPLETION_SOURCE'"
    return 2
  } &
  for job in $(jobs -p | command sort)
  do
    wait "$job" || return $?
  done
  chmod a+x "$INSTALL_DIR/nvm-exec" || {
    nvm_echo >&2 "Failed to mark '$INSTALL_DIR/nvm-exec' as executable"
    return 3
  }
}

nvm_try_profile() {
  if [ -z "${1-}" ] || [ ! -f "${1}" ]; then
    return 1
  fi
  nvm_echo "${1}"
}

#
# Detect profile file if not specified as environment variable
# (eg: PROFILE=~/.myprofile)
# The echo'ed path is guaranteed to be an existing file
# Otherwise, an empty string is returned
#
nvm_detect_profile() {
  if [ "${PROFILE-}" = '/dev/null' ]; then
    # the user has specifically requested NOT to have nvm touch their profile
    return
  fi

  if [ -n "${PROFILE}" ] && [ -f "${PROFILE}" ]; then
    nvm_echo "${PROFILE}"
    return
  fi

  local DETECTED_PROFILE
  DETECTED_PROFILE=''

  if [ "${SHELL#*bash}" != "$SHELL" ]; then
    if [ -f "$HOME/.bashrc" ]; then
      DETECTED_PROFILE="$HOME/.bashrc"
    elif [ -f "$HOME/.bash_profile" ]; then
      DETECTED_PROFILE="$HOME/.bash_profile"
    fi
  elif [ "${SHELL#*zsh}" != "$SHELL" ]; then
    if [ -f "$HOME/.zshrc" ]; then
      DETECTED_PROFILE="$HOME/.zshrc"
    elif [ -f "$HOME/.zprofile" ]; then
      DETECTED_PROFILE="$HOME/.zprofile"
    fi
  fi

  if [ -z "$DETECTED_PROFILE" ]; then
    for EACH_PROFILE in ".profile" ".bashrc" ".bash_profile" ".zprofile" ".zshrc"
    do
      if DETECTED_PROFILE="$(nvm_try_profile "${HOME}/${EACH_PROFILE}")"; then
        break
      fi
    done
  fi

  if [ -n "$DETECTED_PROFILE" ]; then
    nvm_echo "$DETECTED_PROFILE"
  fi
}

#
# Check whether the user has any globally-installed npm modules in their system
# Node, and warn them if so.
#
nvm_check_global_modules() {
  local NPM_COMMAND
  NPM_COMMAND="$(command -v npm 2>/dev/null)" || return 0
  [ -n "${NVM_DIR}" ] && [ -z "${NPM_COMMAND%%"$NVM_DIR"/*}" ] && return 0

  local NPM_VERSION
  NPM_VERSION="$(npm --version)"
  NPM_VERSION="${NPM_VERSION:--1}"
  [ "${NPM_VERSION%%[!-0-9]*}" -gt 0 ] || return 0

  local NPM_GLOBAL_MODULES
  NPM_GLOBAL_MODULES="$(
    npm list -g --depth=0 |
    command sed -e '/ npm@/d' -e '/ (empty)$/d'
  )"

  local MODULE_COUNT
  MODULE_COUNT="$(
    command printf %s\\n "$NPM_GLOBAL_MODULES" |
    command sed -ne '1!p' |                     # Remove the first line
    wc -l | command tr -d ' '                   # Count entries
  )"

  if [ "${MODULE_COUNT}" != '0' ]; then
    # shellcheck disable=SC2016
    nvm_echo '=> You currently have modules installed globally with `npm`. These will no'
    # shellcheck disable=SC2016
    nvm_echo '=> longer be linked to the active version of Node when you install a new node'
    # shellcheck disable=SC2016
    nvm_echo '=> with `nvm`; and they may (depending on how you construct your `$PATH`)'
    # shellcheck disable=SC2016
    nvm_echo '=> override the binaries of modules installed with `nvm`:'
    nvm_echo

    command printf %s\\n "$NPM_GLOBAL_MODULES"
    nvm_echo '=> If you wish to uninstall them at a later point (or re-install them under your'
    # shellcheck disable=SC2016
    nvm_echo '=> `nvm` Nodes), you can remove them from the system Node as follows:'
    nvm_echo
    nvm_echo '     $ nvm use system'
    nvm_echo '     $ npm uninstall -g a_module'
    nvm_echo
  fi
}

nvm_do_install() {
  if [ -n "${NVM_DIR-}" ] && ! [ -d "${NVM_DIR}" ]; then
    if [ -e "${NVM_DIR}" ]; then
      nvm_echo >&2 "File \"${NVM_DIR}\" has the same name as installation directory."
      exit 1
    fi

    if [ "${NVM_DIR}" = "$(nvm_default_install_dir)" ]; then
      mkdir "${NVM_DIR}"
    else
      nvm_echo >&2 "You have \$NVM_DIR set to \"${NVM_DIR}\", but that directory does not exist. Check your profile files and environment."
      exit 1
    fi
  fi
  # Disable the optional which check, https://www.shellcheck.net/wiki/SC2230
  # shellcheck disable=SC2230
  if nvm_has xcode-select && [ "$(xcode-select -p >/dev/null 2>/dev/null ; echo $?)" = '2' ] && [ "$(which git)" = '/usr/bin/git' ] && [ "$(which curl)" = '/usr/bin/curl' ]; then
    nvm_echo >&2 'You may be on a Mac, and need to install the Xcode Command Line Developer Tools.'
    # shellcheck disable=SC2016
    nvm_echo >&2 'If so, run `xcode-select --install` and try again. If not, please report this!'
    exit 1
  fi
  if [ -z "${METHOD}" ]; then
    # Autodetect install method
    if nvm_has git; then
      install_nvm_from_git
    elif nvm_has curl || nvm_has wget; then
      install_nvm_as_script
    else
      nvm_echo >&2 'You need git, curl, or wget to install nvm'
      exit 1
    fi
  elif [ "${METHOD}" = 'git' ]; then
    if ! nvm_has git; then
      nvm_echo >&2 "You need git to install nvm"
      exit 1
    fi
    install_nvm_from_git
  elif [ "${METHOD}" = 'script' ]; then
    if ! nvm_has curl && ! nvm_has wget; then
      nvm_echo >&2 "You need curl or wget to install nvm"
      exit 1
    fi
    install_nvm_as_script
  else
    nvm_echo >&2 "The environment variable \$METHOD is set to \"${METHOD}\", which is not recognized as a valid installation method."
    exit 1
  fi

  nvm_echo

  local NVM_PROFILE
  NVM_PROFILE="$(nvm_detect_profile)"
  local PROFILE_INSTALL_DIR
  PROFILE_INSTALL_DIR="$(nvm_install_dir | command sed "s:^$HOME:\$HOME:")"

  SOURCE_STR="\\nexport NVM_DIR=\"${PROFILE_INSTALL_DIR}\"\\n[ -s \"\$NVM_DIR/nvm.sh\" ] && \\. \"\$NVM_DIR/nvm.sh\"  # This loads nvm\\n"

  # shellcheck disable=SC2016
  COMPLETION_STR='[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion\n'
  BASH_OR_ZSH=false

  if [ -z "${NVM_PROFILE-}" ] ; then
    local TRIED_PROFILE
    if [ -n "${PROFILE}" ]; then
      TRIED_PROFILE="${NVM_PROFILE} (as defined in \$PROFILE), "
    fi
    nvm_echo "=> Profile not found. Tried ${TRIED_PROFILE-}~/.bashrc, ~/.bash_profile, ~/.zprofile, ~/.zshrc, and ~/.profile."
    nvm_echo "=> Create one of them and run this script again"
    nvm_echo "   OR"
    nvm_echo "=> Append the following lines to the correct file yourself:"
    command printf "${SOURCE_STR}"
    nvm_echo
  else
    if nvm_profile_is_bash_or_zsh "${NVM_PROFILE-}"; then
      BASH_OR_ZSH=true
    fi
    if ! command grep -qc '/nvm.sh' "$NVM_PROFILE"; then
      nvm_echo "=> Appending nvm source string to $NVM_PROFILE"
      command printf "${SOURCE_STR}" >> "$NVM_PROFILE"
    else
      nvm_echo "=> nvm source string already in ${NVM_PROFILE}"
    fi
    # shellcheck disable=SC2016
    if ${BASH_OR_ZSH} && ! command grep -qc '$NVM_DIR/bash_completion' "$NVM_PROFILE"; then
      nvm_echo "=> Appending bash_completion source string to $NVM_PROFILE"
      command printf "$COMPLETION_STR" >> "$NVM_PROFILE"
    else
      nvm_echo "=> bash_completion source string already in ${NVM_PROFILE}"
    fi
  fi
  if ${BASH_OR_ZSH} && [ -z "${NVM_PROFILE-}" ] ; then
    nvm_echo "=> Please also append the following lines to the if you are using bash/zsh shell:"
    command printf "${COMPLETION_STR}"
  fi

  # Source nvm
  # shellcheck source=/dev/null
  \. "$(nvm_install_dir)/nvm.sh"

  nvm_check_global_modules

  nvm_install_node

  nvm_reset

  nvm_echo "=> Close and reopen your terminal to start using nvm or run the following to use it now:"
  command printf "${SOURCE_STR}"
  if ${BASH_OR_ZSH} ; then
    command printf "${COMPLETION_STR}"
  fi
}

#
# Unsets the various functions defined
# during the execution of the install script
#
nvm_reset() {
  unset -f nvm_has nvm_install_dir nvm_latest_version nvm_profile_is_bash_or_zsh \
    nvm_source nvm_node_version nvm_download install_nvm_from_git nvm_install_node \
    install_nvm_as_script nvm_try_profile nvm_detect_profile nvm_check_global_modules \
    nvm_do_install nvm_reset nvm_default_install_dir nvm_grep
}

[ "_$NVM_ENV" = "_testing" ] || nvm_do_install

} # this ensures the entire script is downloaded #
</file>

<file path="SelfPacedStudy-backend/LICENSE">
MIT License

Copyright (c) 2024 SelfPacedStudy-Orga

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="SelfPacedStudy-backend/package.json">
{
  "name": "selfpacedstudy-backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.ts",
  "type": "module",
  "scripts": {
    "start": "npm run build && node --experimental-specifier-resolution=node ./build/index.js",
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "tsx watch src",
    "build": "rimraf ./build && tsc",
    "lint": "eslint src",
    "format": "eslint src --fix"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/fluent-ffmpeg": "^2.1.24",
    "@types/multer": "^1.4.11",
    "@types/node": "^20.11.5",
    "@types/nodemailer": "^6.4.14",
    "@types/pdfkit": "^0.13.4",
    "@typescript-eslint/eslint-plugin": "^6.19.0",
    "@typescript-eslint/parser": "^6.19.0",
    "eslint": "^8.56.0",
    "rimraf": "^5.0.5",
    "ts-node": "^10.9.2",
    "tsx": "^4.7.0",
    "typescript": "^5.8.2"
  },
  "dependencies": {
    "@langchain/community": "^0.0.19",
    "@langchain/core": "^0.3.43",
    "@langchain/openai": "^0.0.5",
    "arg": "^5.0.2",
    "cors": "^2.8.5",
    "csv-writer": "^1.6.0",
    "dotenv": "^16.4.7",
    "express": "^4.18.2",
    "fetch-blob": "^4.0.0",
    "fluent-ffmpeg": "^2.1.2",
    "langchain": "^0.1.0",
    "multer": "^1.4.5-lts.1",
    "natural": "^8.0.1",
    "node-fs": "^0.1.7",
    "node-html-parser": "^6.1.13",
    "nodemailer": "^6.9.13",
    "pdf-lib": "^1.17.1",
    "pdf-parse": "^1.1.1",
    "pdfkit": "^0.15.0",
    "peggy": "^3.0.2",
    "winston": "^3.11.0",
    "youtube-screenshot": "1.0.2"
  }
}
</file>

<file path="SelfPacedStudy-backend/README.md">
# AI-Powered Real-Time Support Tool for Self-Paced Studying

## Overview

This application serves as the backbone for the SelfPacedStudy platform, offering real-time assistance and support to learners engaged in self-paced study through pre-recorded online lecture videos and accompanying slides. Our AI-powered support tool, the Lecture Learning Model (LLM), acts as a chatbot, responding to user queries based on the lecture video and slides provided. The LLM uses the lecture video and slides transcripts as context to provide more accurate answers to your questions.

The backend application is designed to handle API requests, manage memory and serve data to the frontend. This project is specifically tailored to work with GPT-4-Vision, enabling image upload functionality.

We could introduce context and memory into the models with the useful approach of [Langchain](https://js.langchain.com/docs/get_started/introduction) where the corpus of text is preprocessed by breaking it down into chunks or summaries, embedding them in a vector space, and searching for similar chunks when a question is asked.

_Developed for the Project Week at TUM._

## Getting Started

### Prerequisites

- Node.js
- npm
- GPT-4-Vision API key

### Installation

1. Clone the repository: `git clone https://github.com/SelfPacedStudy-Orga/SelfPacedStudy-backend.git`
2. Navigate to the project directory: `cd SelfPacedStudy-backend`
3. Install the dependencies: `npm install`

### Configuration

Copy the `.env.example` file and rename it to `.env`. Fill in the necessary environment variables.

## Running the Application

To start the server in development mode, run: `npm run dev`

## Project Structure

The main codebase is located in the `/src` directory. Here's a brief overview of each subdirectory:

- `/src/controllers`: This directory contains all the controller files. Controllers handle the business logic of the application.

- `/src/routes`: This directory contains all the route definitions for the Express application. Routes define the endpoints of the application.

- `/src/services`: This directory contains all the service files. Services are used for external APIs, processing data, handling complex functionalities etc.

- `/src/utils`: This directory contains utility files. These are helper functions or classes that are used across multiple files in the application.

## API Endpoints

- **Chat Endpoint (`/chats`)**: Manages incoming and outgoing chat messages.
- **Transcript Endpoint (`/transcript`)**: Initializes the context for the LLM by handling transcripts of video and slides.

## Contributing

If you want to contribute to this project, please create a new branch, make your changes, and create a pull request.
</file>

<file path="SelfPacedStudy-backend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    // Set the JavaScript version
    "module": "esnext",
    "moduleResolution": "node",
    "outDir": "./build",
    "rootDir": "./src",
    "esModuleInterop": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "skipLibCheck": true,
    "paths": {
      "@routes/*": [
        "src/routes/*"
      ],
      "@controllers/*": [
        "src/controllers/*"
      ],
      "@services/*": [
        "src/services/*"
      ],
      "@db/*": [
        "src/db/*"
      ],
      "@utils/*": [
        "src/utils/*"
      ],
      "@models/*": [
        "src/models/*"
      ],
      "@config/*": [
        "src/config/*"
      ],
    }
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="SelfPacedStudy-ui/.git/hooks/applypatch-msg.sample">
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:
</file>

<file path="SelfPacedStudy-ui/.git/hooks/commit-msg.sample">
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}
</file>

<file path="SelfPacedStudy-ui/.git/hooks/fsmonitor-watchman.sample">
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}
</file>

<file path="SelfPacedStudy-ui/.git/hooks/post-update.sample">
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info
</file>

<file path="SelfPacedStudy-ui/.git/hooks/pre-applypatch.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:
</file>

<file path="SelfPacedStudy-ui/.git/hooks/pre-commit.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --
</file>

<file path="SelfPacedStudy-ui/.git/hooks/pre-merge-commit.sample">
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:
</file>

<file path="SelfPacedStudy-ui/.git/hooks/pre-push.sample">
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0
</file>

<file path="SelfPacedStudy-ui/.git/hooks/pre-rebase.sample">
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END
</file>

<file path="SelfPacedStudy-ui/.git/hooks/pre-receive.sample">
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi
</file>

<file path="SelfPacedStudy-ui/.git/hooks/prepare-commit-msg.sample">
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi
</file>

<file path="SelfPacedStudy-ui/.git/hooks/push-to-checkout.sample">
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi
</file>

<file path="SelfPacedStudy-ui/.git/hooks/update.sample">
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0
</file>

<file path="SelfPacedStudy-ui/.git/info/exclude">
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
</file>

<file path="SelfPacedStudy-ui/.git/logs/refs/heads/main">
0000000000000000000000000000000000000000 e2af3afad0bea03d33ff83f261ac42ec8611e7e1 Baronage Zhang <baronagezhang@MacBook-Pro-3.local> 1743496530 +0800	clone: from https://github.com/SelfPacedStudy-Orga/SelfPacedStudy-ui.git
</file>

<file path="SelfPacedStudy-ui/.git/logs/refs/remotes/origin/HEAD">
0000000000000000000000000000000000000000 e2af3afad0bea03d33ff83f261ac42ec8611e7e1 Baronage Zhang <baronagezhang@MacBook-Pro-3.local> 1743496530 +0800	clone: from https://github.com/SelfPacedStudy-Orga/SelfPacedStudy-ui.git
</file>

<file path="SelfPacedStudy-ui/.git/logs/HEAD">
0000000000000000000000000000000000000000 e2af3afad0bea03d33ff83f261ac42ec8611e7e1 Baronage Zhang <baronagezhang@MacBook-Pro-3.local> 1743496530 +0800	clone: from https://github.com/SelfPacedStudy-Orga/SelfPacedStudy-ui.git
</file>

<file path="SelfPacedStudy-ui/.git/refs/heads/main">
e2af3afad0bea03d33ff83f261ac42ec8611e7e1
</file>

<file path="SelfPacedStudy-ui/.git/refs/remotes/origin/HEAD">
ref: refs/remotes/origin/main
</file>

<file path="SelfPacedStudy-ui/.git/config">
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
	precomposeunicode = true
[remote "origin"]
	url = https://github.com/SelfPacedStudy-Orga/SelfPacedStudy-ui.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main
	vscode-merge-base = origin/main
	vscode-merge-base = origin/main
</file>

<file path="SelfPacedStudy-ui/.git/description">
Unnamed repository; edit this file 'description' to name the repository.
</file>

<file path="SelfPacedStudy-ui/.git/HEAD">
ref: refs/heads/main
</file>

<file path="SelfPacedStudy-ui/.git/packed-refs">
# pack-refs with: peeled fully-peeled sorted 
0c50a835cf1ca1557332427c8fdeb82af5f0a936 refs/remotes/origin/fix-sizing
a06e954249cb2bb4ccf7c82a7ed89f4292b10018 refs/remotes/origin/hai_group_features
e2af3afad0bea03d33ff83f261ac42ec8611e7e1 refs/remotes/origin/main
76dfbaf11e9640f6b44f7b9a7a1935f9f110bf2b refs/remotes/origin/ozan-try
</file>

<file path="SelfPacedStudy-ui/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="SelfPacedStudy-ui/public/privacy.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Privacy Policy</title>
</head>
<body>
    <h1>Privacy Policy</h1>
    <p>This project is a research initiative of the Technical University of Munich (TUM), offering an interactive learning tool that integrates YouTube videos. Users can interact with ChatGPT to ask questions related to the videos. The data protection regulations of the Technical University of Munich apply to the use of this tool.</p>
    <p>At the Technical University of Munich, privacy is of utmost importance. We want you to know when we collect data and how it is used. We process personal data collected during your visit to our websites in accordance with applicable data protection regulations, particularly the Bavarian Data Protection Act (BayDSG) and the Telemedia Act (TMG).</p>

    <p>Below, we inform you about the type, scope, and purpose of the collection and use of personal data.</p>

    <h2>General Information</h2>
    <h3>Name and Contact Information of the Responsible Entity</h3>
    <ul class="contact-info">
        <li><strong>Technical University of Munich</strong></li>
        <li>Mailing Address: Arcisstraße 21, 80333 Munich</li>
        <li>Phone: +49-(0)89-289-01</li>
        <li>Email: poststelle(at)tum.de</li>
    </ul>

    <h3>Contact Information for the Data Protection Officer</h3>
    <ul class="contact-info">
        <li><strong>Data Protection Officer of the Technical University of Munich</strong></li>
        <li>Mailing Address: Arcisstraße 21, 80333 Munich</li>
        <li>Phone: +49-(0)89-289-17052</li>
        <li>Email: beauftragter(at)datenschutz.tum.de</li>
    </ul>

    <h2>Purpose and Legal Basis for Processing Personal Data</h2>
    <p>Personal data collected in connection with this learning tool is used to ensure the correct functionality of the website. The following data is collected and processed:</p>
    <ul>
        <li>Your text input is processed by the OpenAI API for interaction with ChatGPT.</li>
        <li>Conversations and interactions are stored to improve the functionality and quality of the tool.</li>
        <li>Text inputs from users are processed via the OpenAI API.</li>
    </ul>

    <h3>Use of the OpenAI API</h3>
    <p>The feedback generation and interaction are performed using the third-party provider "OpenAI OpCo, LLC" (<a href="https://openai.com" target="_blank">https://openai.com</a>).</p>
    <p>According to OpenAI, it assists its customers in complying with data protection laws, including GDPR and CCPA. OpenAI’s "API Data Usage Policies" state that data is not used to train or improve their models. The data is stored for up to 30 days for abuse monitoring purposes and is then deleted.</p>

    <h2>Further Information</h2>
    <p>For more information on the processing of your data and your rights, you can contact us using the contact details provided above.</p>

    <h2>Information About the Website</h2>
    <h3>Technical Implementation</h3>
    <p>The website is hosted on a server in the Frankfurt region of Amazon Web Services (AWS).</p>
    <p>You can prevent the recording of your microphone and audio playback by adjusting your browser settings. However, please note that in this case, you may not be able to use all the functions of this website fully.</p>

    <h3>Logging</h3>
    <p>When you access this or other websites, data is transmitted from your internet browser to our web server. The following data is temporarily recorded in a log file during an active connection for communication between your internet browser and our web server:</p>
    <ul>
        <li>IP address of the requesting computer</li>
        <li>Date and time of access</li>
        <li>Name, URL, and amount of data transferred of the retrieved file</li>
        <li>Access status (file transferred, not found, etc.)</li>
        <li>Identification data of the browser and operating system used (if transmitted by the requesting web browser)</li>
        <li>Web page from which the access was made (if transmitted by the requesting web browser)</li>
    </ul>
    <p>The processing of the data in this log file is carried out as follows:</p>
    <ul>
        <li>Log entries are continuously evaluated to detect and respond to attacks on the web servers.</li>
        <li>In individual cases, such as reported malfunctions, errors, and security incidents, a manual analysis is performed.</li>
    </ul>

    <h2>Right to Information and Correction</h2>
    <p>You have the right to request information about the personal data stored about you, free of charge and in writing. You also have the right to request the correction of incorrect data. You can contact the Data Protection Officer of the Technical University of Munich by email at beauftragter(at)datenschutz.tum.de or via <a href="http://www.datenschutz.tum.de" target="_blank">www.datenschutz.tum.de</a>.</p>
</body>
</html>
</file>

<file path="SelfPacedStudy-ui/public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="SelfPacedStudy-ui/src/app/classroom/page.tsx">
'use client';

import React, { useCallback, useEffect, useRef, useState } from 'react';
import ChatToolbar from "../../components/chat/ChatToolbar";
import ChatBox from "@/components/chat/ChatBox";
import Box from '@mui/material/Box';
import Slide from '@mui/material/Slide';
import { useRouter, useSearchParams } from 'next/navigation';
import { IMessage } from '@/components/chat/Message';
import useOutsideClickDetector from "@/utils/UseOutsideClickDetectorHook";
import AlertDialog from "@/components/generic/AlertDialog";
import Cookies from 'js-cookie';
import VideoPlayer from "../../components/video-player/VideoPlayer";
import ClassroomToolbar from "@/components/generic/ClassroomToolbar";
import CustomAlertModal from "@/components/generic/CustomAlertModal"; // Import the custom alert modal

const ClassroomPage = () => {
    const router = useRouter();
    const searchParams = useSearchParams();

    const [isChatBoxOpen, setIsChatBoxOpen] = useState(false);
    const [isVideoManuallyPaused, setIsVideoManuallyPaused] = useState(true);
    const [messages, setMessages] = useState<IMessage[]>([{
        id: 1,
        text: "Hi there, how can I help you?",
        sender: "bot",
        isImage: false,
        image: null
    }]);
    const [videoPosition, setVideoPosition] = useState(0);
    const [videoDuration, setVideoDuration] = useState(0); // New state for video duration
    const [isInLastTwentyMinutes, setIsInLastTwentyMinutes] = useState(false); // State to check if in last 20 minutes
    const [uploadedImage, setUploadedImage] = useState<File | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [alertDialogOpen, setAlertDialogOpen] = useState(false);
    const [showSlideMessage, setShowSlideMessage] = useState(false);
    const [capturedImageUrl, setCapturedImageUrl] = useState<string | null>(null);
    const [shouldHideChatBox, setShouldHideChatBox] = useState(false); // Updated state
    const [permissionGranted, setPermissionGranted] = useState(false);
    const mediaRecorderRef = useRef<MediaRecorder | null>(null);
    const recordedChunksRef = useRef<any[]>([]);
    const [isUserInitiatedPause, setIsUserInitiatedPause] = useState(false);
    const [customAlertOpen, setCustomAlertOpen] = useState(false); // State to control custom alert modal
    const [popupVisible, setPopupVisible] = useState(false); // State to manage popup visibility
    const [controlPopup, setControlPopup]= useState(true);
    const [popupAppearedTimestamp, setPopupAppearedTimestamp] = useState<number | null>(null); // Capture the timestamp when the popup appears
    const containerRef = useRef(null);
    const chatBoxRef = useRef(null);
    const inputBaseRef = useRef(null);
    const imageButtonRef = useRef(null);
    const sendButtonRef = useRef(null);
    const videoUrl = searchParams.get('videoUrl');
    const fromExperiment = searchParams.get('fromExperiment') === 'true'; // Get the fromExperiment parameter
    const [userId, setUserId] = useState('');
    const isControlGroup = searchParams.get('isTest') === 'yes'; // Get the isTest parameter and set isControlGroup to true if it is "yes"


    useEffect(() => {
        const userIdFromCookies = Cookies.get('userId');
        if (userIdFromCookies) {
            setUserId(userIdFromCookies);
        }
    }, []);

    useEffect(() => {
        const fetchShouldHideChatBox = async () => {
            try {
                console.log("fetchShouldHideChatBox")
                if (fromExperiment) {
                const userId = Cookies.get('userId');
                if (userId) {
                    const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/initialize`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ userId, fromExperiment })
                    });
                    const data = await response.json();
                    
                    
                    setShouldHideChatBox(data.shouldHideChatBox === 'true');
                    console.log("ShouldHideChatBox")
                    console.log(data)
                }
            }
            } catch (error) {
                console.error('Error fetching shouldHideChatBox:', error);
            }
        };
        fetchShouldHideChatBox();
    }, [fromExperiment]);
    

    useEffect(() => {
        if (fromExperiment) {
            const handleBeforeUnload = (event: BeforeUnloadEvent) => {
                event.preventDefault();
                setCustomAlertOpen(true); // Show custom alert modal
                event.returnValue = ''; // Legacy method for cross-browser support
            };
    
            window.addEventListener('beforeunload', handleBeforeUnload);
    
            return () => {
                window.removeEventListener('beforeunload', handleBeforeUnload);
            };
        }
    }, [userId, fromExperiment]);

    
    useEffect(() => {
        const handleBeforeUnload = (event: BeforeUnloadEvent) => {
            const url = process.env.NEXT_PUBLIC_BACKEND_URL + "/chats/save";
            const userId = Cookies.get('userId');
            const formData = new FormData();
            formData.append('userId', userId!);
            console.log("Save");
            console.log(shouldHideChatBox);
            console.log(shouldHideChatBox.toString());
    
            formData.append('shouldHideChatBox', shouldHideChatBox.toString());
            formData.append('fromExperiment', fromExperiment.toString());
            if (!navigator.sendBeacon(url, formData)) {
                fetch(url, {
                    method: 'POST',
                    body: formData,
                    keepalive: true,
                });
            }
    
            // Optionally, you can add a message to prevent accidental closure (not reliable across all browsers):
            event.preventDefault();
            event.returnValue = ''; // This triggers a confirmation dialog in some browsers
        };
    
        window.addEventListener('beforeunload', handleBeforeUnload);
        return () => {
            window.removeEventListener('beforeunload', handleBeforeUnload);
        };
    }, [fromExperiment, shouldHideChatBox]);

    
    
    useEffect(() => {
        if (!videoUrl) {
            router.replace('/');
        }
    }, [videoUrl, router]);

    useEffect(() => {
        if (!fromExperiment) {
            setAlertDialogOpen(true);
        }
    }, [fromExperiment]);

    useEffect(() => {
        const intervalId = setInterval(() => {
            //console.log("check")
            //console.log(videoDuration)
            if (fromExperiment && videoDuration > 0 && videoPosition >= (videoDuration - 1200)) {
                setIsInLastTwentyMinutes(true);
                //console.log("true")
            } else {
                setIsInLastTwentyMinutes(false);
                //console.log("false")

            }
        }, 2000); // Check every 30 seconds

        return () => clearInterval(intervalId);
    }, [fromExperiment, videoDuration, videoPosition]);

    useEffect(() => {
        
    if(controlPopup){
        if (videoDuration > 0 && videoPosition >= (videoDuration / 2)) {
            setPopupAppearedTimestamp(Date.now()); // Set the timestamp when the popup appears
            setPopupVisible(true);
            setIsVideoManuallyPaused(true);
            setControlPopup(false);
        }
    }}, [videoPosition, videoDuration]);

    const handleAlertBoxClose = () => {
        setAlertDialogOpen(false);
        if (!fromExperiment) {
            requestScreenRecordingPermission(); // Request permission right after closing the alert dialog if not from experiment
        }
    }

    const handleBack = () => {
        router.replace('/');
    };

    useEffect(() => {
        if (uploadedImage != null) {
            const newMessage: IMessage = {
                id: messages.length + 1,
                text: "",
                sender: "user",
                isImage: true,
                image: uploadedImage
            }
            setMessages(prevMessages => [...prevMessages, newMessage]);
        }
    }, [uploadedImage]);

    useOutsideClickDetector(chatBoxRef, () => {
        if (isChatBoxOpen) setIsChatBoxOpen(false);
    }, [inputBaseRef, imageButtonRef, sendButtonRef]);

    const handleNewMessage = useCallback(async (newMessageText: string) => {
        const newMessage: IMessage = {
            id: messages.length + 1,
            text: newMessageText,
            sender: "user",
            isImage: false,
            image: null
        };
        setMessages(prevMessages => [...prevMessages, newMessage]);
        setIsLoading(true);

        const formData = new FormData();
        formData.append('message', newMessageText);
        formData.append('videoPosition', videoPosition.toString());
        const currentTimestamp = Date.now();
        const timestampString = currentTimestamp.toString();
        formData.append('normalTimestamp', timestampString);

        if (uploadedImage) {
            formData.append('imageData', uploadedImage);
            setUploadedImage(null);
        }

        const userId = Cookies.get('userId');
        if (!userId) {
            console.error("UserID not found in cookies!");
        } else {
            formData.append('userId', userId);
        }
        formData.append('fromExperiment', fromExperiment.toString());

        // Append the captured image URL if available
        if (newMessageText.toLowerCase().includes("slide")) {
            if (capturedImageUrl) {
                const response = await fetch(capturedImageUrl);
                const blob = await response.blob();
                formData.append('imageData', blob, 'screenshot.png');
            }
        }

        fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/chats`, {
            method: 'POST',
            body: formData
        })
            .then(response => response.json())
            .then(data => {
                const returnMessage: IMessage = {
                    id: messages.length + 1,
                    text: data.result,
                    sender: "bot",
                    isImage: data.message === "Image uploaded",
                    image: null
                }
                setMessages(prevMessages => [...prevMessages, returnMessage]);
                setIsLoading(false);

                setCapturedImageUrl(null);
            })
            .catch(error => console.error('Error:', error));
    }, [videoPosition, uploadedImage, capturedImageUrl]);

    const handleImageUpload = useCallback((file: File) => {
        if (!isChatBoxOpen) setIsChatBoxOpen(true);
        setUploadedImage(file);
    }, [isChatBoxOpen]);

    
    const handleHistoryDownload = async () => {
        try {
            const userId = Cookies.get('userId');
            if (!userId) {
                throw new Error('User ID not found');
            }
    
            const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/chats/history`, {
                method: 'POST',
                headers: {
                    'Accept': 'application/pdf',
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ userId, fromExperiment }), // Include fromExperiment in the request body
            });
    
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
    
            const chatHistoryBlob = await response.blob();
            const blob = new Blob([chatHistoryBlob], { type: 'application/pdf' });
    
            const link = document.createElement('a');
            link.href = window.URL.createObjectURL(blob);
            link.download = "mypdfDocument.pdf";
            link.click();
    
        } catch (error) {
            console.error('Error downloading the PDF:', error);
        }
    }
    
    
    const requestScreenRecordingPermission = async () => {
        try {
            // Prompt user for screen recording permission
            const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
            let mediaRecorder;

            // Check for Safari browser
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

            if (isSafari) {
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/mp4' });
            } else {
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
            }

            mediaRecorderRef.current = mediaRecorder;

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunksRef.current.push(event.data);
                }
            };

            mediaRecorder.onstop = async () => {
                if (recordedChunksRef.current.length === 0) {
                    return;
                }

                const mimeType = isSafari ? 'video/mp4' : 'video/webm';
                const blob = new Blob(recordedChunksRef.current, { type: mimeType });
                const url = URL.createObjectURL(blob);

                const video = document.createElement('video');
                video.src = url;

                video.onloadeddata = () => {
                    if (video.videoWidth && video.videoHeight) {
                        const canvas = document.createElement('canvas');
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        const context = canvas.getContext('2d');
                        if (context) {
                            context.drawImage(video, 0, 0, canvas.width, canvas.height);
                            const imgData = canvas.toDataURL('image/png');
                            setCapturedImageUrl(imgData);
                            console.log("New Image is captured")
                            URL.revokeObjectURL(url);
                        } else {
                            console.error('Failed to get canvas context.');
                        }
                    } else {
                        console.error('Video loaded but no frames were captured.');
                    }
                };

                video.onerror = (error) => {
                    console.error('Error loading video for screenshot capture:', error);
                };

                video.play().catch(error => console.error('Error playing video for screenshot capture:', error));
            };

            mediaRecorder.start();
            setPermissionGranted(true);
        } catch (error) {
            console.error('Error requesting screen recording permission:', error);
            alert('Screen recording permission was denied or an error occurred.');
        }
    };

    const handleScreenshotCapture = () => {
        if (mediaRecorderRef.current && permissionGranted) {
            if (mediaRecorderRef.current.state !== 'inactive') {
                mediaRecorderRef.current.stop();
            }
            recordedChunksRef.current = [];
            mediaRecorderRef.current.start();
            setTimeout(() => {
                if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                    mediaRecorderRef.current.stop();
                }
            }, 500); // Record for a very short duration
        }
    };
    
    const handleOpenChatBox = () => {
        setIsVideoManuallyPaused(true);
    
        if (fromExperiment) {
            setTimeout(() => {
                setIsChatBoxOpen(true);
            }, 500); // Delay of 0.5 second
        } else {
            setIsChatBoxOpen(true);
        }
    };
    

    const handlePause = (isPaused: boolean) => {
        if (isPaused) {
            handleScreenshotCapture();  // Capture screenshot every time the video is paused
        }
        setIsUserInitiatedPause(isPaused);
    };
    
    useEffect(() => {
        if (isUserInitiatedPause) {
            handleScreenshotCapture();
        }
    }, [isUserInitiatedPause]);

    const handlePopupClose = async () => {
        console.log("Closed 1")
        console.log(popupAppearedTimestamp)

        if (popupAppearedTimestamp) {
            const reactionTime = Date.now() - popupAppearedTimestamp; // Calculate reaction time
            const userId = Cookies.get('userId');
            console.log("Closed")
            console.log(reactionTime)

            if (userId) {
                const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/chats/getReactionTime`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ userId,fromExperiment, reactionTime })
                });
                if (!response.ok) {
                    console.error('Error sending reaction time:', response.statusText);
                }
            }
        }
    
        setPopupVisible(false);
        setIsVideoManuallyPaused(false);
    };

    return (
        <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh' }}>
            <AlertDialog
                open={alertDialogOpen}
                handleClose={handleAlertBoxClose}
                title=""
                description={
                    <span>
                        Before you start chatting, please note that we will save your chat history after the session ends. 
                        Starting the chat implies your acknowledgment.
                        You can also download your chat as PDF by clicking the download button anytime. <br />
                        <strong>Note: You will be asked to share your screen. Please ensure you only share the current window.</strong>
                    </span>
                }
            />
            <ClassroomToolbar 
                onBack={handleBack} 
                onDownload={handleHistoryDownload} 
                userId={userId} 
                fromExperiment={fromExperiment} 
                isControlGroup={isControlGroup}
                isInLastTwentyMinutes={isInLastTwentyMinutes} 
                shouldHideChatBox = {shouldHideChatBox}
            />
            <Box sx={{ display: 'flex', flexDirection: 'column', height: '-webkit-fill-available', padding: '5px' }}>
                <Box sx={{ flexGrow: 1, position: 'relative', width: '100%', overflow: 'hidden' }} ref={containerRef}>
                    <VideoPlayer
                        url={videoUrl || ''}
                        isChatBoxOpen={isChatBoxOpen}
                        isVideoManuallyPaused={isVideoManuallyPaused}
                        setIsVideoManuallyPaused={(value: boolean) => {
                            setIsVideoManuallyPaused(value);
                            if (value) {
                                handlePause(value);
                            }
                        }}
                        setVideoPosition={setVideoPosition}
                        setVideoDuration={setVideoDuration} // Set video duration
                    />
                    {isChatBoxOpen && (
                        <Box sx={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', backgroundColor: 'rgba(0, 0, 0, 0.5)', zIndex: 1200 }} />
                    )}
                    {isChatBoxOpen && (
                        <Slide in={isChatBoxOpen} direction="up" container={containerRef.current}>
                            <Box sx={{ position: 'absolute', width: '100%', bottom: 0, zIndex: 1300 }} ref={chatBoxRef}>
                                <ChatBox messages={messages} isLoading={isLoading} />
                            </Box>
                        </Slide>
                    )}
                {popupVisible && (
                    <Box sx={{ 
                        position: 'absolute', 
                        top: '50%', 
                        left: '50%', 
                        transform: 'translate(-50%, -50%)', 
                        zIndex: 1400, 
                        backgroundColor: 'white', 
                        padding: '40px', // Increased padding to make the box bigger
                        borderRadius: '8px', 
                        boxShadow: 3, 
                        textAlign: 'center',
                        width: '400px' // Added width to make the box bigger
                    }}>
                        <p>Would you like to continue to watch Video?</p>
                        <Box sx={{ marginTop: '20px' }}>
                            <button onClick={handlePopupClose} style={{ 
                                backgroundColor: '#1976d2',  // Assuming this is the same color code used for other buttons
                                color: 'white',  // Changed text color to white
                                padding: '10px 20px', 
                                border: 'none', 
                                borderRadius: '4px', 
                                cursor: 'pointer' 
                            }}>
                                Continue
                            </button>
                        </Box>
                    </Box>
                )}
                </Box>
                {!shouldHideChatBox && (
                    <ChatToolbar
                        onOpenChatBox={handleOpenChatBox}
                        onCloseChatBox={() => setIsChatBoxOpen(false)}
                        isChatBoxOpen={isChatBoxOpen}
                        inputRef={inputBaseRef}
                        imageButtonRef={imageButtonRef}
                        sendButtonRef={sendButtonRef}
                        onSendMessage={handleNewMessage}
                        onImageUpload={handleImageUpload}
                    />
                )}
            </Box>
            <CustomAlertModal 
                open={customAlertOpen} 
                onClose={() => setCustomAlertOpen(false)} 
                userId={userId} 
                fromExperiment={fromExperiment} 
                isControlGroup={isControlGroup} 
                shouldHideChatbox={shouldHideChatBox} 

            />
        </Box>
    );
};

export default ClassroomPage;
</file>

<file path="SelfPacedStudy-ui/src/app/experiment/page.tsx">
'use client';

import { useRouter } from 'next/navigation';
import { createTheme, ThemeProvider } from '@mui/material/styles';
import { themeOptions } from '@/theme/theme';
import TumBar from '@/components/tum-bar/TumBar';
import Typography from '@mui/material/Typography';
import Grid from '@mui/material/Grid';
import React, { useEffect, useState } from "react";
import AlertDialog from "@/components/generic/AlertDialog";
import { List, ListItem, ListItemText, Button } from '@mui/material';
import Slide from '@mui/material/Slide';
import IconButton from '@mui/material/IconButton';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import ArrowNextIcon from '@mui/icons-material/ArrowForward';
import CircularProgress from '@mui/material/CircularProgress';
import Box from '@mui/material/Box';
import { WELCOME_MESSAGE, READY_TO_LEARN_MESSAGE, INSTRUCTION_1, INSTRUCTION_2, INSTRUCTION_3 } from '@/utils/constants';
import ContactSupportIcon from '@mui/icons-material/ContactSupport';
import Tooltip from '@mui/material/Tooltip';
import { GlobalStyles } from '@mui/material';
import Cookies from 'js-cookie';
import { v4 as uuidv4 } from 'uuid';

const theme = createTheme(themeOptions);

const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'row',
    width: '100%',
    height: '100vh',
}

const rightContainerStyle: React.CSSProperties = {
    width: "100%",
    marginLeft: '10%',
    overflowY: 'scroll',
};

const globalScrollbarStyles = {
    '& .hideScrollbar::-webkit-scrollbar': {
        display: 'none'
    },
    '& .hideScrollbar': {
        scrollbarWidth: 'none', // Firefox
        msOverflowStyle: 'none', // Internet Explorer 10+
    }
};

const contactIconStyle: React.CSSProperties = {
    position: 'fixed',
    bottom: 20,
    right: 20,
    cursor: 'pointer' // Optional, to indicate that it’s interactive
};

const Page = () => {
    const router = useRouter();
    const [dialogOpen, setDialogOpen] = useState(false); // State to hold if the alert is open.
    const [isStarted, setIsStarted] = useState(false);
    const [isLoading, setIsLoading] = useState(false); // Loading state between this page and the classroom component.
    const [fromExperiment, setfromExperiment] = useState(true); // Loading state between this page and the classroom component.
    const userId = Cookies.get('userId') || uuidv4();

    useEffect(() => {
        if (!Cookies.get('userId')) {
          Cookies.set('userId', userId, { expires: 365 });
        }
      }, [userId]);

    const handleSubmit = async (lectureNumber: string) => {
        setIsLoading(true);

        try {
            const formData = new FormData();
            

            formData.append('userId', userId);
            formData.append('fromExperiment', fromExperiment.toString()); // Adding user ID to the form data

            formData.append('lectureNumber', lectureNumber);
            
            console.log(lectureNumber)

            const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/transcriptExperiment`, {
                method: 'POST',
                body: formData
            });
            const result = await response.json();

            const videoUrl = result.videoUrl;
            const url = `/classroom?videoUrl=${encodeURIComponent(videoUrl)}&fromExperiment=true`;
            if (url) {
                router.push(url);
            }
            setIsLoading(false);
        } catch (error) {
            setIsLoading(false);
        }
    };

    const handleStart = () => {
        setIsStarted(true);
    };

    const handleBack = () => {
        setIsStarted(false);
    }

    const handleDialogClose = () => {
        setDialogOpen(false);
    };
    

    const handleRedirect = () => {
        let userId = Cookies.get('userId');
        if (!userId) {
            userId = uuidv4();
            Cookies.set('userId', userId!, { expires: 365 });
        }
        window.open(`https://qualtricsxmfhtr3d79f.qualtrics.com/jfe/form/SV_4Ufzk9YbwRUy7gq?PROLIFIC_PID=${userId}`, '_blank');
    };
    

    return (
        <>
            <GlobalStyles styles={globalScrollbarStyles} />
            <ThemeProvider theme={theme}>
                <div style={containerStyle}>
                    <TumBar />
                    <Grid style={{ display: 'flex', flexDirection: 'row', alignItems: 'center', width: '60%', overflowY: 'scroll' }}>
                        {isStarted && (
                            <>
                                <Grid item ml={5}>
                                    <IconButton style={{ color: "#919191", marginLeft: '0px' }} edge="start"
                                                onClick={handleBack}>
                                        <ArrowBackIcon fontSize='large' />
                                    </IconButton>
                                </Grid>

                                <Slide direction="left" in={isStarted} mountOnEnter unmountOnExit>
                                    <Grid className="hideScrollbar" item style={rightContainerStyle}>
                                        <Button
                                            variant="contained"
                                            color="primary"
                                            onClick={handleRedirect}
                                            style={{ margin: '10px' }}
                                        >
                                            Fill out the pre-questionnaire. Your ID: {userId}
                                        </Button>
                                        <Typography variant="h5" style={{ marginTop: '20px', marginBottom: '10px' }}>
                                            Available Lectures
                                        </Typography>
                                        <Button
                                            variant="contained"
                                            color="primary"
                                            onClick={() => handleSubmit('10')}
                                            style={{ margin: '10px' }}
                                        >
                                            Lecture 10
                                        </Button>
                                        <Button
                                            variant="contained"
                                            color="primary"
                                            onClick={() => handleSubmit('11')}
                                            style={{ margin: '10px' }}
                                        >
                                            Lecture 11
                                        </Button>
                                        <Button
                                            variant="contained"
                                            color="primary"
                                            onClick={() => handleSubmit('12')}
                                            style={{ margin: '10px' }}
                                        >
                                            Lecture 12
                                        </Button>
                                    </Grid>
                                </Slide>
                            </>
                        )}
                        {!isStarted && (
                            <Slide direction="left" in={!isStarted} mountOnEnter unmountOnExit>
                                <Grid className="hideScrollbar" item style={rightContainerStyle}>
                                    <Typography variant="h2" color={'secondary'}>{WELCOME_MESSAGE}</Typography>
                                    <Typography variant="h6" style={{ marginTop: '5%', color: 'rgba(0, 0, 0, 0.7)' }}>
                                        {READY_TO_LEARN_MESSAGE}
                                    </Typography>
                                    <List>
                                        <ListItem key="item2">
                                            <ListItemText
                                                primary={INSTRUCTION_1} />
                                        </ListItem>
                                        <ListItem key="item3">
                                            <ListItemText
                                                primary={INSTRUCTION_2} />
                                        </ListItem>
                                        <ListItem key="item4">
                                            <ListItemText
                                                primary={INSTRUCTION_3} />
                                        </ListItem>
                                    </List>
                                </Grid>
                            </Slide>
                        )}
                        <Grid item mr={5}>
                            {!isStarted ? (
                                <IconButton size="large" onClick={handleStart} edge='end'>
                                    <ArrowNextIcon fontSize='large' color='secondary' />
                                </IconButton>
                            ) : (
                                <Box sx={{ display: 'flex' }}>
                                    {isLoading && <CircularProgress />}
                                </Box>
                            )}
                        </Grid>
                    </Grid>
                </div>
            </ThemeProvider>
            <Tooltip title={<React.Fragment>Email: <b>sam.ai.mentor@sot.tum.de</b><br />Contact us for more info!</React.Fragment>}
                     placement="top" arrow>
                <ContactSupportIcon style={contactIconStyle} color="primary" fontSize="large" />
            </Tooltip>
            <AlertDialog
                open={dialogOpen}
                handleClose={handleDialogClose}
                title="Missing Video URL"
                description="Please provide a video URL to continue."
            />
        </>
    );
};

export default Page;
</file>

<file path="SelfPacedStudy-ui/src/app/mlexperiment/page.tsx">
'use client';

import { useRouter } from 'next/navigation';
import { createTheme, ThemeProvider } from '@mui/material/styles';
import { themeOptions } from '@/theme/theme';
import TumBar from '@/components/tum-bar/TumBar';
import Typography from '@mui/material/Typography';
import Grid from '@mui/material/Grid';
import React, { useEffect, useState } from "react";
import AlertDialog from "@/components/generic/AlertDialog";
import { Button } from '@mui/material';
import Slide from '@mui/material/Slide';
import CircularProgress from '@mui/material/CircularProgress';
import Box from '@mui/material/Box';
import { GlobalStyles } from '@mui/material';
import Cookies from 'js-cookie';
import { v4 as uuidv4 } from 'uuid';
import ContactSupportIcon from '@mui/icons-material/ContactSupport';
import Tooltip from '@mui/material/Tooltip';
import { WELCOME_MESSAGE, READY_TO_LEARN_MESSAGE, INSTRUCTION_1, INSTRUCTION_2, INSTRUCTION_3 ,  READY_TO_LEARN_INTRO, KEY_FEATURES_TITLE,
    KEY_FEATURES,
    READY_TO_LEARN_OUTRO} from '@/utils/constants'; // Adjust to your constants
import { List, ListItem, ListItemText } from '@mui/material';
import IconButton from '@mui/material/IconButton';
import ArrowNextIcon from '@mui/icons-material/ArrowForward';

const theme = createTheme(themeOptions);

const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'row',
    width: '100%',
    height: '100vh',
};

const rightContainerStyle: React.CSSProperties = {
    width: "70%",  // Slightly wider but not too much
    maxWidth: '800px', // Adjust the max width to give a more readable line length
    marginLeft: '5%',
    overflowY: 'scroll',
};

const globalScrollbarStyles = {
    '& .hideScrollbar::-webkit-scrollbar': {
        display: 'none'
    },
    '& .hideScrollbar': {
        scrollbarWidth: 'none', // Firefox
        msOverflowStyle: 'none', // Internet Explorer 10+
    }
};

const contactIconStyle: React.CSSProperties = {
    position: 'fixed',
    bottom: 20,
    right: 20,
    cursor: 'pointer' // Optional, to indicate that it’s interactive
};

const arrowStyle: React.CSSProperties = {
    position: 'fixed',  // Fix the arrow to the right side
    right: '20px',  // Right side alignment
    top: '50%',  // Vertically center the arrow
    transform: 'translateY(-50%)',  // Ensure it's centered relative to its height
    fontSize: '40px'
};

const buttonContainerStyle: React.CSSProperties = {
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    height: '100vh',  // Full height to center the button vertically
    width: '100%',
};

const Page = () => {
    const router = useRouter();
    const [dialogOpen, setDialogOpen] = useState(false); // State to hold if the alert is open.
    const [isLoading, setIsLoading] = useState(false); // Loading state for transitioning between pages.
    const [isStarted, setIsStarted] = useState(false); // State to toggle between welcome message and interaction
    const [fromExperiment, setFromExperiment] = useState(true); // Represents if user comes from experiment
    const [userId, setUserId] = useState<string | null>(null);
    const [prolificID, setProlificID] = useState<string | null>(null);
    const [isTest, setIsTest] = useState<string>('false'); // Ensure it is always a string

    useEffect(() => {
        const urlParams = new URLSearchParams(window.location.search);
        const prolificIDParam = urlParams.get('prolificID') || uuidv4(); // Ensure it always gets a string
        const isTestParam = urlParams.get('isTest') || 'false'; // Ensure it always gets a string
        setProlificID(prolificIDParam);
        setIsTest(isTestParam); // Ensure the parameter is set correctly
        Cookies.set('userId', prolificIDParam, { expires: 365 });
        setUserId(prolificIDParam);
    }, []);

    const handleSubmit = async (lectureNumber: string) => {
        if (!userId) return; // Ensure userId is available before proceeding
        setIsLoading(true);

        try {
            const formData = new FormData();
            formData.append('userId', userId);
            formData.append('fromExperiment', fromExperiment.toString()); // Adding user ID to the form data
            formData.append('lectureNumber', lectureNumber);
            formData.append('isTest', isTest); // Adding isTest to the form data

            const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/transcriptExperiment`, {
                method: 'POST',
                body: formData
            });
            const result = await response.json();

            const videoUrl = result.videoUrl;
            const url = `/classroom?videoUrl=${encodeURIComponent(videoUrl)}&fromExperiment=${fromExperiment}&isTest=${isTest}`;
            if (url) {
                router.push(url);
            }
            setIsLoading(false);
        } catch (error) {
            setIsLoading(false);
        }
    };

    const handleDialogClose = () => {
        setDialogOpen(false);
    };

    const handleStart = () => {
        setIsStarted(true); // Start the interaction after welcome screen
    };

    return (
        <>
            <GlobalStyles styles={globalScrollbarStyles} />
            <ThemeProvider theme={theme}>
                <div style={containerStyle}>
                    <TumBar />
                    <Grid style={{ display: 'flex', flexDirection: 'row', alignItems: 'flex-start', width: '100%', overflowY: 'scroll' }}>
                        
                        {/* If not started, show welcome instructions */}
                        {!isStarted && (
                            <Slide direction="left" in={!isStarted} mountOnEnter unmountOnExit>
  <Grid className="hideScrollbar" item style={rightContainerStyle}>
    {/* Welcome Message */}
    <Typography variant="h2" color={'secondary'}>
      {WELCOME_MESSAGE}
    </Typography>

    {/* Ready to Learn Message Intro */}
    <Typography variant="h6" style={{ marginTop: '5%', color: 'rgba(0, 0, 0, 0.7)' }}>
      {READY_TO_LEARN_INTRO}
    </Typography>

    {/* Key Features Title */}
    <Typography variant="h6" style={{ marginTop: '5%', color: 'rgba(0, 0, 0, 0.7)' }}>
      {KEY_FEATURES_TITLE}
    </Typography>

    {/* Key Features List with Smaller Font and Bold */}
    <List>
      {KEY_FEATURES.map((feature, index) => (
        <ListItem key={`feature-${index}`}>
          <Typography variant="body1" style={{ fontWeight: 'bold', color: 'rgba(0, 0, 0, 0.7)' }}>
            • {feature}
          </Typography>
        </ListItem>
      ))}
    </List>

    {/* Ready to Learn Outro */}
    <Typography variant="h6" style={{ marginTop: '5%', color: 'rgba(0, 0, 0, 0.7)' }}>
      {READY_TO_LEARN_OUTRO}
    </Typography>
  </Grid>
</Slide>
                        )}

                        {/* If started, show the button to proceed */}
                        {isStarted && (
                            <Slide direction="left" in={isStarted} mountOnEnter unmountOnExit>
                                <Grid className="hideScrollbar" item style={rightContainerStyle}>
                                    <div style={buttonContainerStyle}>
                                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                                            <Button
                                                variant="contained"
                                                color="primary"
                                                onClick={() => handleSubmit('15')}
                                                disabled={isLoading}  // Disable the button while loading
                                            >
                                                Watch Lecture
                                            </Button>

                                            {/* Show the loading spinner to the right of the button if loading */}
                                            {isLoading && (
                                                <Box sx={{ marginLeft: '10px' }}>
                                                    <CircularProgress size={24} />
                                                </Box>
                                            )}
                                        </Box>
                                    </div>
                                </Grid>
                            </Slide>
                        )}

                        {/* Add the arrow to the right side and vertically centered */}
                        <IconButton size="large" onClick={handleStart} edge='end' style={arrowStyle}>
                            <ArrowNextIcon fontSize='large' color='secondary' />
                        </IconButton>
                    </Grid>
                </div>
            </ThemeProvider>
            <Tooltip title={<React.Fragment>Email: <b>sam.ai.mentor@sot.tum.de</b><br />Contact us for more info!</React.Fragment>}
                     placement="top" arrow>
                <ContactSupportIcon style={contactIconStyle} color="primary" fontSize="large" />
            </Tooltip>
            <AlertDialog
                open={dialogOpen}
                handleClose={handleDialogClose}
                title="Missing Video URL"
                description="Please provide a video URL to continue."
            />
        </>
    );
};

export default Page;
</file>

<file path="SelfPacedStudy-ui/src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: light) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: white;
  width: 100vw;
  height: 100vh;
}

.loader {
  width: 30px;
  aspect-ratio: 1;
  --_c:no-repeat radial-gradient(farthest-side,#0065bd 92%,#0000);
  background: 
    var(--_c) top,
    var(--_c) left,
    var(--_c) right,
    var(--_c) bottom;
  background-size: 8px 8px;
  animation: l7 1s infinite;
}
@keyframes l7 {to{transform: rotate(.5turn)}}
</file>

<file path="SelfPacedStudy-ui/src/app/layout.tsx">
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'SAM',
  description: 'Personalized AI Mentor',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
          {children}
      </body>
    </html>
  )
}
</file>

<file path="SelfPacedStudy-ui/src/app/page.tsx">
'use client';

import {useRouter} from 'next/navigation';
import {createTheme, ThemeProvider} from '@mui/material/styles';
import {themeOptions} from '@/theme/theme';
import Upload from '@/components/upload/Upload';
import TumBar from '@/components/tum-bar/TumBar';
import Typography from '@mui/material/Typography';
import Grid from '@mui/material/Grid';
import React, {useEffect, useRef, useState} from "react";
import AlertDialog from "@/components/generic/AlertDialog";
import {List, ListItem, ListItemText} from '@mui/material';
import Slide from '@mui/material/Slide';
import IconButton from '@mui/material/IconButton';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import ArrowNextIcon from '@mui/icons-material/ArrowForward';
import CircularProgress from '@mui/material/CircularProgress';
import Box from '@mui/material/Box';
import { WELCOME_MESSAGE, READY_TO_LEARN_MESSAGE, INSTRUCTION_1, INSTRUCTION_2, INSTRUCTION_3 } from '@/utils/constants';
import ContactSupportIcon from '@mui/icons-material/ContactSupport';
import Tooltip from '@mui/material/Tooltip';
import {GlobalStyles} from '@mui/material';
import Cookies from 'js-cookie';
import { v4 as uuidv4 } from 'uuid';
import Button from '@mui/material/Button'; // Import the Button component


const theme = createTheme(themeOptions);

const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'row',
    width: '100%',
    height: '100vh',
}

const rightContainerStyle: React.CSSProperties = {
    width: "100%",
    marginLeft: '10%',
    overflowY: 'scroll',
};

const globalScrollbarStyles = {
    '& .hideScrollbar::-webkit-scrollbar': {
        display: 'none'
    },
    '& .hideScrollbar': {
        scrollbarWidth: 'none', // Firefox
        msOverflowStyle: 'none', // Internet Explorer 10+
    }
};

const contactIconStyle: React.CSSProperties = {
    position: 'fixed',
    bottom: 20,
    right: 20,
    cursor: 'pointer' // Optional, to indicate that it’s interactive
};

/**
 * Page serves as the starting point for users to interact with the AI-powered support tool.
 * It allows users to upload lecture videos and slides, and provides instructions on how to use the tool.
 */
const Page = () => {
    const router = useRouter();
    const [lectureSlidesFiles, setLectureSlidesFiles] = useState<File[]>([]); // State to hold uploaded slides.
    const [videoUrl, setVideoUrl] = useState<string>(''); // State to hold entered video URL
    const [lectureVideoFile, setLectureVideoFile] = useState<File[]>([]); // State to hold the lecture video file.
    const buttonRef = useRef<HTMLButtonElement | null>(null); // Reference to the arrow buttons between the tutorial and the upload components.
    const [dialogOpen, setDialogOpen] = useState(false); // State to hold if the alert is open.
    const [isStarted, setIsStarted] = useState(false);
    const [isLoading, setIsLoading] = useState(false); // Loading state between this page and the classroom component.
    const [isVideoUrlValid, setIsVideoUrlValid] = useState(true); //State to hold the validity of the URL.
    const [fromExperiment, setfromExperiment] = useState(false); // Loading state between this page and the classroom component.



    useEffect(() => {
        router.push('https://sam.edu.sot.tum.de/mlexperiment?isTest=yes&prolificID=yourProlificIDValue');
    }, [router]);

    return null; // No need to render anything as it's only for redirection

    /*
    On a possible return to this page, we don't want the user to be able to go back with the same data.
     */
    useEffect(() => {
        // Reset the state variables when the component mounts
        setLectureSlidesFiles([]);
        setVideoUrl('');
        setLectureVideoFile([]);
                

    }, []);

    

    /**
     * Handles the submission of lecture slides and video URL.
     * Validates the input, displays a dialog if the video URL is missing,
     * and sends the data to the server for processing.
     */
    const handleSubmit = async () => {
        if (!isStarted) {
            setIsStarted(true);
            return;
        }

        if (!videoUrl) {
            // Show the popup
            setDialogOpen(true);
            return;
        }

        setIsLoading(true);

        try {

            /*
            const formData2 = new FormData();
            formData2.append('test', 'value');

            const response2 = await fetch('https://tum-hctl-vr-hub.link/app2/transcript', {
                method: 'POST',
                body: formData2,
            });

            //console.log(await response2.json());
            */

            const formData = new FormData();

            // Check for existing user ID in cookies or generate a new one
            let userId = Cookies.get('userId');
            if (!userId) {
                userId = uuidv4();
                Cookies.set('userId', userId!, { expires: 365 }); // Store user ID in cookies with 1 year expiration
            }

            lectureSlidesFiles.forEach(file => {
                formData.append('pdfs', file);
            });
            //console.log(videoUrl)
            formData.append('url', videoUrl);
            //formData.append('url', 'fdsaf');

            formData.append('userId', userId); // Adding user ID to the form data
            //console.log(process.env.NEXT_PUBLIC_BACKEND_URL)
            const temp = false;
            formData.append('fromExperiment', fromExperiment.toString()); // Adding user ID to the form data

            // Assuming formData is already populated with files and fields
            for (var pair of formData.entries()) {
                //console.log(pair[0]+ ', ' + pair[1]);
            }
            //console.log("we sent response")
            console.log("Page Main App" + formData)

            const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/transcript`, {
                method: 'POST',
                body: formData
            });
            const result = await response.json();
            //console.log(result);
            //console.log("we got response")

            const url = `/classroom?videoUrl=${encodeURIComponent(videoUrl)}`;
            if (url) {
                router.push(url);
            }
            setIsLoading(false);
        } catch (error) {
            //console.log("Error uploading data!");
            setIsLoading(false);
        }
    };

    /**
     * Resets the 'isStarted' state to allow the user to go back to the initial view.
     */
    const handleBack = () => {
        setIsStarted(false);
    }


    const handleDialogClose = () => {
        setDialogOpen(false);
    };

    return (
        <>
            <GlobalStyles styles={globalScrollbarStyles} />
            <ThemeProvider theme={theme}>
                <div style={containerStyle}>
                    <TumBar/>
                    <Grid style={{display: 'flex', flexDirection: 'row', alignItems: 'center', width: '60%', overflowY: 'scroll'}}>
                        {isStarted && (
                            <>
                                <Grid item ml={5}>
                                    <IconButton style={{color: "#919191", marginLeft: '0px'}} edge="start"
                                                onClick={handleBack}>
                                        <ArrowBackIcon fontSize='large'/>
                                    </IconButton>
                                </Grid>

                                <Slide direction="left" in={isStarted} mountOnEnter unmountOnExit>
                                    <Grid className="hideScrollbar" item style={rightContainerStyle}>
                                        <Upload
                                            title="Lecture Video"
                                            urlFlag={true}
                                            dragzoneFlag={false}
                                            allowedFileTypes=".*/mp4"
                                            maxFileSize={50}
                                            url={videoUrl}
                                            setUrl={setVideoUrl}
                                            files={lectureVideoFile}
                                            setFiles={setLectureVideoFile}
                                            setIsVideoUrlValid={setIsVideoUrlValid}
                                        />
                                        <Upload
                                            title="Lecture Slides (Optional)"
                                            urlFlag={false}
                                            dragzoneFlag={true}
                                            allowedFileTypes=".pdf, .pptx, .ppt"
                                            maxFileSize={50}
                                            files={lectureSlidesFiles}
                                            setFiles={setLectureSlidesFiles}
                                            description="You can also upload previous slides of the lecture."
                                        />
                                    </Grid>
                                </Slide>
                            </>
                        )}
                        {!isStarted && (
                            <Slide direction="left" in={!isStarted} mountOnEnter unmountOnExit>
                                <Grid className="hideScrollbar" item style={rightContainerStyle}>
                                    <Typography variant="h2" color={'secondary'}>{WELCOME_MESSAGE}</Typography>
                                    <Typography variant="h6" style={{marginTop: '5%', color: 'rgba(0, 0, 0, 0.7)'}}>
                                        {READY_TO_LEARN_MESSAGE}
                                    </Typography>
                                    <List>
                                        <ListItem key="item2">
                                            <ListItemText
                                                primary={INSTRUCTION_1}/>
                                        </ListItem>
                                        <ListItem key="item3">
                                            <ListItemText
                                                primary={INSTRUCTION_2}/>
                                        </ListItem>
                                        <ListItem key="item4">
                                            <ListItemText
                                                primary={INSTRUCTION_3}/>
                                        </ListItem>
                                    </List>
                                </Grid>
                            </Slide>
                        )}
                        <Grid item mr={5}>
                            {isLoading ? (
                                <Box sx={{display: 'flex'}}>
                                    <CircularProgress/>
                                </Box>
                            ) : (
                                <IconButton ref={buttonRef} size="large" onClick={handleSubmit} edge='end'
                                            disabled={!isVideoUrlValid}>
                                    <ArrowNextIcon fontSize='large' color='secondary'/>
                                </IconButton>
                            )}
                        </Grid>
                    </Grid>
                </div>
                <a href="/privacy.html" target="_blank" rel="noopener noreferrer">
                    <Button variant="contained" color="primary" style={{position: 'fixed', bottom: 80, right: 20}}>
                        Privacy Policy
                    </Button>
                </a>
            </ThemeProvider>
            <Tooltip title={<React.Fragment>Email: <b>sam.ai.mentor@sot.tum.de</b><br/>Contact us for more info!</React.Fragment>}
                     placement="top" arrow>
                <ContactSupportIcon style={contactIconStyle} color="primary" fontSize="large"/>
            </Tooltip>
            <AlertDialog
                open={dialogOpen}
                handleClose={handleDialogClose}
                title="Missing Video URL"
                description="Please provide a video URL to continue."
            />
        </>);
};

export default Page;
</file>

<file path="SelfPacedStudy-ui/src/components/chat/ChatBox.tsx">
"use client";
import React, {useEffect, useRef, useState} from 'react';
import {Box} from "@mui/material";
import Message, {IMessage} from './Message';


const chatBoxStyles: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    backgroundColor: 'rgb(247, 247, 247)',
    resize: 'none',
}

const messageListStyles: (height: string) => React.CSSProperties = (height) => ({
    height,
    overflow: "auto",
    paddingTop: "1rem",
});

const resizeHandleStyles: React.CSSProperties = {
    cursor: 'ns-resize',
    height: '0.5rem',
    backgroundColor: '#0065bd',
};

interface ChatBoxProps {
    messages: IMessage[]; // Array of chat messages to be displayed
    isLoading: boolean; // Indicates whether the chat box is in a loading state
}

const ChatBox: React.FC<ChatBoxProps> = ({messages, isLoading}) => {
    const [chatBoxHeight, setChatBoxHeight] = useState('300px'); // State for managing the height of the chat box
    const chatBoxRef = useRef<HTMLDivElement>(null); // Ref to the chat box container for resizing
    const resizeHandleRef = useRef<HTMLDivElement>(null); // Ref to the resize handle of the chat box
    const scrollRef = useRef<HTMLDivElement>(null);


    /*
    This acts as an auto-scroller for the ChatBox. It scrolls to an invisible div at the bottom of the ChatBox.
     */
    const scrollToBottom = () => {
        if (scrollRef.current) {
            const scrollHeight = scrollRef.current.scrollHeight;
            const height = scrollRef.current.clientHeight;
            const maxScrollTop = scrollHeight - height;
            scrollRef.current.scrollTop = maxScrollTop > 0 ? maxScrollTop : 0;
        }
    };

    useEffect(() => {
        scrollToBottom();
    }, [messages]);

    /**
     * Provides functionality to resize the ChatBox via dragging its upper edge.
     * @param mouseDownEvent - To be able to understand if user is dragging.
     */
    const startResizing = (mouseDownEvent: React.MouseEvent<HTMLDivElement, MouseEvent>) => {
        mouseDownEvent.preventDefault();

        const startY = mouseDownEvent.clientY;
        const startHeight = chatBoxRef.current?.clientHeight || 0;

        const doResize = (mouseMoveEvent: MouseEvent) => {
            if (chatBoxRef.current) {
                const newHeight = startHeight - (mouseMoveEvent.clientY - startY);
                setChatBoxHeight(`${newHeight}px`);
            }
        };

        const stopResizing = () => {
            window.removeEventListener('mousemove', doResize);
            window.removeEventListener('mouseup', stopResizing);
            scrollToBottom();
        };

        window.addEventListener('mousemove', doResize);
        window.addEventListener('mouseup', stopResizing);
    };

    return (
        <Box
            style={{...chatBoxStyles, height: chatBoxHeight}}
            ref={chatBoxRef}>
            <div style={resizeHandleStyles} onMouseDown={startResizing} ref={resizeHandleRef}></div>
            <Box style={messageListStyles(chatBoxHeight)} ref={scrollRef}>
                {messages.map((message) => (
                    <Message key={message.id} message={message} isLoading={false}/>
                ))}
                {isLoading &&
                    <Message key={messages.length + 1}
                             message={{id: messages.length + 1, text: "", sender: "bot", isImage: false, image: null}}
                             isLoading={true}/>
                }
            </Box>
        </Box>
    );
};

export default ChatBox;
</file>

<file path="SelfPacedStudy-ui/src/components/chat/ChatToolbar.tsx">
"use client";

import React, {RefObject, useRef} from 'react';
import {Box, IconButton, InputBase} from "@mui/material";
import {alpha, experimentalStyled} from '@mui/material/styles';
import ImageIcon from '@mui/icons-material/Image';
import KeyboardDoubleArrowUpIcon from '@mui/icons-material/KeyboardDoubleArrowDown';
import KeyboardDoubleArrowDownIcon from '@mui/icons-material/KeyboardDoubleArrowDown';
import SendIcon from '@mui/icons-material/Send';
import CustomIconButton from '@/components/generic/CustomIconButton';

const Search = experimentalStyled('div')(({theme}) => ({
    position: 'relative',
    borderRadius: 45,
    backgroundColor: alpha(theme.palette.common.white, 1),
    '&:hover': {
        backgroundColor: alpha(theme.palette.common.white, 0.8),
    },
    marginRight: theme.spacing(2),
    marginLeft: 0,
    marginTop: theme.spacing(1),
    marginBottom: theme.spacing(1),
    width: '100%',
    [theme.breakpoints.up('sm')]: {
        marginLeft: theme.spacing(3),
        width: 'auto',
    },
}));

const StyledInputBase = experimentalStyled(InputBase)(({theme}) => ({
    color: '#000000',
    '& .MuiInputBase-input': {
        paddingLeft: `calc(1em + ${theme.spacing(0.5)})`,
        transition: theme.transitions.create('width'),
    },
}));

interface ChatToolbarProps {
    onOpenChatBox: () => void;
    onCloseChatBox: () => void;
    isChatBoxOpen: boolean;
    inputRef: RefObject<HTMLInputElement>;
    imageButtonRef: RefObject<HTMLButtonElement>;
    sendButtonRef: RefObject<HTMLButtonElement>;
    onSendMessage: (message: string, file?: File) => void;
    onImageUpload: (file: File) => void;
}

const ChatToolbar: React.FC<ChatToolbarProps> = ({
    onOpenChatBox,
    onCloseChatBox,
    isChatBoxOpen,
    inputRef,
    imageButtonRef,
    sendButtonRef,
    onSendMessage,
    onImageUpload
}) => {
    const toggleIcon = isChatBoxOpen ? <KeyboardDoubleArrowDownIcon/> : <KeyboardDoubleArrowUpIcon/>;
    const fileInputRef = useRef<HTMLInputElement>(null);

    const handleImageUpload = () => {
        if (fileInputRef.current) {
            fileInputRef.current.click();
        }
    };

    const handleSendMessage = () => {
        if (inputRef.current && inputRef.current.value) {
            onSendMessage(inputRef.current.value);
            inputRef.current.value = '';
        }
    };

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const files = event.target.files;
        if (files && files.length > 0) {
            const file = files[0];
            onImageUpload(file);
        }
    };

    return (
        <Box
            sx={{
                backgroundColor: '#0065bd',
                display: 'flex',
                flexDirection: 'row',
                alignItems: 'center',
                borderBottomLeftRadius: '16px',
                borderBottomRightRadius: '16px',
                height: 'auto',
                padding: '10px',
                WebkitOverflowScrolling: 'touch',
            }}>
            <IconButton style={{color: "white", marginLeft: '5px'}} edge="start"
                        onClick={isChatBoxOpen ? onCloseChatBox : onOpenChatBox}
                        aria-label="toggle chat box">
                {toggleIcon}
            </IconButton>
            <input
                type="file"
                style={{display: 'none'}}
                ref={fileInputRef}
                onChange={handleFileChange}
                accept="image/*"
            />
            <CustomIconButton ref={imageButtonRef} style={{color: "white"}} edge="end" onClick={handleImageUpload}>
                <ImageIcon/>
            </CustomIconButton>
            <Search sx={{flexGrow: 1}}>
                <StyledInputBase sx={{width: '100%'}}
                                 placeholder="Type a message"
                                 inputProps={{'aria-label': 'search'}}
                                 onFocus={onOpenChatBox}
                                 inputRef={inputRef}
                                 onKeyDown={(e) => {
                                     if (e.key === 'Enter') {
                                         e.preventDefault();
                                         handleSendMessage();
                                     }
                                 }}
                />
            </Search>
            <CustomIconButton ref={sendButtonRef} style={{color: "white", marginRight: '10px'}} edge="start"
                              onClick={handleSendMessage}>
                <SendIcon/>
            </CustomIconButton>
        </Box>
    );
};

export default ChatToolbar;
</file>

<file path="SelfPacedStudy-ui/src/components/chat/Message.tsx">
"use client";
import React from 'react';
import {Avatar, Box, Paper, Typography} from "@mui/material";
import ImageIcon from '@mui/icons-material/Image';
import parseLatex from "@/utils/ParseLatex";
import 'katex/dist/katex.min.css';
import '../../app/globals.css';
import SmartToyOutlinedIcon from '@mui/icons-material/SmartToyOutlined';
import PersonOutlineOutlinedIcon from '@mui/icons-material/PersonOutlineOutlined';

export interface IMessage {
    id: number; // Unique identifier for the message
    text: string; // The text content of the message
    sender: string; // Identifier for the sender ('bot' or 'user')
    isImage: boolean; // Flag indicating if the message is an image
    image: File | null ;
}

const Message = ({message, isLoading}: { message: IMessage, isLoading: boolean }) => {
    const isBot = message.sender === "bot";

    const containerStyles: React.CSSProperties = {
        display: 'flex',
        justifyContent: isBot ? 'flex-start' : 'flex-end',
        marginBottom: '1rem',

    };

    const innerContainerStyles: React.CSSProperties = {
        display: 'flex',
        flexDirection: isBot ? 'row' : 'row-reverse',
        alignItems: 'center',
    };

    const avatarStyles: React.CSSProperties = {
        backgroundColor: isBot ? 'orange' : 'gray',
    };

    const paperStyles: React.CSSProperties = {
        padding: '1rem',
        margin: isBot ? '0 3rem 1rem 0.5rem' : '0 0.5rem 1rem 0',
        backgroundColor: isBot ? 'white' : 'white',
        borderRadius: isBot ? '20px 20px 20px 5px' : '20px 20px 5px 20px',
    };

    /**
     * If the content of the message is text, parse the text so that katex can display equations.
     */
    const content = message.isImage && message.image ? (
        <img src={URL.createObjectURL(message.image)} alt="Message Image" style={{ width: 'auto', height: '100%' }} />
    ) : parseLatex(message.text);



    return (
        <Box style={containerStyles}>
            <Box style={innerContainerStyles}>
                <Avatar style={avatarStyles}>
                    {isBot ? <SmartToyOutlinedIcon/> : <PersonOutlineOutlinedIcon/>}
                </Avatar>
                <Paper style={paperStyles}>
                    {
                        isLoading ?
                            (
                                <div className="loader"></div>
                            )
                            :
                            (
                                message.isImage && message.image ?
                                    (
                                        <img src={URL.createObjectURL(message.image)} alt="Message Image"
                                             style={{width: 'auto', height: '100px'}}/>)
                                    :
                                    (
                                        <Typography variant="body1">{content}</Typography> //Otherwise, render the Latex + text content
                                    )
                            )
                    }
                </Paper>
            </Box>
        </Box>
    );
};

export default Message;
</file>

<file path="SelfPacedStudy-ui/src/components/generic/AlertDialog.tsx">
import * as React from 'react';
import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';

// Define the props interface
interface AlertDialogProps {
    open: boolean; // If alertBox is open or not.
    handleClose: () => void; //Call when alertDialog is closed.
    title: string;
    description: React.ReactNode; // Change this line
}

/**
 * Used in the main "Page" component to warn users if they did not enter a URL.
 * @param open
 * @param handleClose
 * @param title
 * @param description
 * @constructor
 */
const AlertDialog: React.FC<AlertDialogProps> = ({open, handleClose, title, description}) => {
    return (
        <Dialog
            open={open}
            onClose={handleClose}
            aria-labelledby="alert-dialog-title"
            aria-describedby="alert-dialog-description"
        >
            <DialogTitle id="alert-dialog-title">{title}</DialogTitle>
            <DialogContent>
                <DialogContentText id="alert-dialog-description">
                    {description}
                </DialogContentText>
            </DialogContent>
            <DialogActions>
                <Button onClick={handleClose}>Understood</Button>
            </DialogActions>
        </Dialog>
    );
};

export default AlertDialog;
</file>

<file path="SelfPacedStudy-ui/src/components/generic/CircularProgressWithLabel.tsx">
import * as React from 'react';
import CircularProgress, {CircularProgressProps,} from '@mui/material/CircularProgress';
import Typography from '@mui/material/Typography';
import Box from '@mui/material/Box';

/**
 * Used in displaying the loading screens.
 * @param props
 * @constructor
 */
export const CircularProgressWithLabel = (props: CircularProgressProps & { value: number }) => {
    return (
        <Box sx={{position: 'relative', display: 'inline-flex'}}>
            <CircularProgress variant="determinate" {...props} />
            <Box
                sx={{
                    top: 0,
                    left: 0,
                    bottom: 0,
                    right: 0,
                    position: 'absolute',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                }}
            >
                <Typography
                    variant="caption"
                    component="div"
                    color="text.secondary"
                >{`${Math.round(props.value)}%`}</Typography>
            </Box>
        </Box>
    );
}
</file>

<file path="SelfPacedStudy-ui/src/components/generic/ClassroomToolbar.tsx">
// ClassroomToolbar.tsx
import React from 'react';
import { AppBar, Box, IconButton, Toolbar, Typography, Button } from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import Image from 'next/image';
import tum_logo from '../../../public/tum_logo.png';
import FileDownloadIcon from '@mui/icons-material/FileDownload';
import { useRouter } from 'next/navigation';

interface SimpleToolbarProps {
    onBack: () => void;
    onDownload: () => void;
    userId: string;
    fromExperiment: boolean;
    isControlGroup: boolean;
    isInLastTwentyMinutes: boolean;
    shouldHideChatBox: boolean;
}

export const handleRedirect = (userId: string, fromExperiment: boolean, shouldHideChatBox: boolean, isControlGroup: boolean) => {

    const url = process.env.NEXT_PUBLIC_BACKEND_URL + "/chats/onlysave";
    console.log("ONLY SAVE")
    const formData = new FormData();
    formData.append('userId', userId!);
    console.log("Save")
    console.log(shouldHideChatBox)
    console.log(shouldHideChatBox.toString())
    formData.append('shouldHideChatBox', shouldHideChatBox.toString());
    formData.append('fromExperiment', fromExperiment.toString());
    if (!navigator.sendBeacon(url, formData)) {
        fetch(url, {
            method: 'POST',
            body: formData,
            keepalive: true,
        });
    }
    if (fromExperiment) {
        console.log("ControlGroup" + isControlGroup)
        if (isControlGroup) {
            window.open(`https://qualtricsxmfhtr3d79f.qualtrics.com/jfe/form/SV_0Nkh74oYWMscIfQ?PROLIFIC_PID=${userId}`, '_blank');
        } else {
            window.open(`https://qualtricsxmfhtr3d79f.qualtrics.com/jfe/form/SV_54rCTamNPVK5Fc2?PROLIFIC_PID=${userId}`, '_blank');
        } 
    } else {
        window.open(`https://qualtricsxmfhtr3d79f.qualtrics.com/jfe/form/SV_ex3hIADNmA5exqS?PROLIFIC_PID=${userId}`, '_blank');
    }
};







const ClassroomToolbar: React.FC<SimpleToolbarProps> = ({ onBack, onDownload, userId, fromExperiment, isControlGroup, isInLastTwentyMinutes,shouldHideChatBox }) => {
    const router = useRouter();

    return (
        <AppBar position="sticky" color="default" elevation={1} sx={{ width: '100%', margin: 0 }}>
            <Toolbar sx={{ minHeight: '0px !important', padding: '0px' }}>
                <IconButton size='small' edge="start" color="inherit" aria-label="back" onClick={onBack}>
                    <ArrowBackIcon fontSize='small' />
                </IconButton>
                <Box sx={{ flexGrow: 1 }} />
                {isInLastTwentyMinutes && fromExperiment && (
                    <Typography variant="h6" color="error" sx={{ mr: 4 }}>
                        Please fill out the questionnaire.
                    </Typography>
                )}
                <Button 
                    variant="contained" 
                    color="primary" 
                    onClick={() => handleRedirect(userId, fromExperiment,shouldHideChatBox, isControlGroup)} 
                    sx={{ mr: 2, backgroundColor: 'red', '&:hover': { backgroundColor: 'darkred' } }}
                >
                    {fromExperiment ? "Fill out the questionnaire" : "Usability Test"}
                </Button>
                <Typography variant="h6" color="inherit" component="div" sx={{ lineHeight: '1', mr: 2 }}>
                    <Image src={tum_logo} alt="TUM Logo" width={40} height={22} />
                </Typography>
                <IconButton size='small' edge="start" color="inherit" aria-label="download" onClick={onDownload}>
                    <FileDownloadIcon fontSize='small' />
                </IconButton>
            </Toolbar>
        </AppBar>
    );
};

export default ClassroomToolbar;
</file>

<file path="SelfPacedStudy-ui/src/components/generic/CustomAlertModal.tsx">
// CustomAlertModal.tsx
import React from 'react';
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import Modal from '@mui/material/Modal';
import Typography from '@mui/material/Typography';
import { handleRedirect } from './ClassroomToolbar'; // Adjust the path as necessary

interface CustomAlertModalProps {
    open: boolean;
    onClose: () => void;
    userId: string;
    fromExperiment: boolean;
    isControlGroup: boolean;
    shouldHideChatbox: boolean;
}

const CustomAlertModal: React.FC<CustomAlertModalProps> = ({ open, onClose, userId, fromExperiment, isControlGroup,shouldHideChatbox }) => {
    return (
        <Modal
            open={open}
            onClose={onClose}
            aria-labelledby="modal-title"
            aria-describedby="modal-description"
        >
            <Box sx={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                width: 400,
                bgcolor: 'background.paper',
                border: '2px solid #000',
                boxShadow: 24,
                p: 4,
            }}>
                <Typography id="modal-title" variant="h6" component="h2">
                    Did you fill in the questionnaire?
                </Typography>
                <Typography id="modal-description" sx={{ mt: 2 }}>
                    Please fill in the post questionnaire.
                </Typography>
                <Button
                    variant="contained"
                    color="primary"
                    onClick={() => {
                        console.log(userId,fromExperiment,isControlGroup)
                        handleRedirect(userId, fromExperiment, shouldHideChatbox,isControlGroup);
                        onClose();
                    }}
                    sx={{ mt: 2 }}
                >
                    Go to Questionnaire
                </Button>
            </Box>
        </Modal>
    );
};

export default CustomAlertModal;
</file>

<file path="SelfPacedStudy-ui/src/components/generic/CustomIconButton.tsx">
import React, {forwardRef} from 'react';
import IconButton, {IconButtonProps} from '@mui/material/IconButton';

type Ref = HTMLButtonElement;

/**
 * A wrapper created to be able to pass references to MUI IconButtons.
 */
const CustomIconButton = forwardRef<Ref, IconButtonProps>((props, ref) => (
    // Use ref directly instead of innerRef
    <IconButton {...props} ref={ref}/>
));

CustomIconButton.displayName = 'CustomIconButton'; // Set the displayName

export default CustomIconButton;
</file>

<file path="SelfPacedStudy-ui/src/components/generic/LinkTypography.tsx">
import {Typography, TypographyProps} from '@mui/material';
import {useTheme} from '@mui/material/styles';

interface LinkTypographyProps extends TypographyProps {
    onClick: () => void;
    text: string;
    disabled?: boolean;
}

const linkTyphographyStyles: React.CSSProperties = {
    textDecoration: 'underline',
    cursor: 'pointer',
};

const LinkTypography: React.FC<LinkTypographyProps> = ({onClick, text, ...props}) => {
    const theme = useTheme();

    return (
        <Typography
            variant="body1"
            display="inline"
            component="span"
            onClick={onClick}
            style={linkTyphographyStyles}
            color={props.disabled ? 'lightgrey' : 'primary'}
            {...props}
        >
            {text}
        </Typography>
    );
}

export default LinkTypography;
</file>

<file path="SelfPacedStudy-ui/src/components/generic/TitleTypography.tsx">
import React from 'react';
import {Typography, TypographyProps} from '@mui/material';

interface TitleTypographyProps extends TypographyProps {
    text: string;
}

const TitleTypography: React.FC<TitleTypographyProps> = (props) => {
    return (
        <Typography variant="h5" style={{color: 'rgba(0, 0, 0, 0.7)', marginBottom: '2%'}}>
            {props.text}
        </Typography>
    );
};


export default TitleTypography;
</file>

<file path="SelfPacedStudy-ui/src/components/tum-bar/TumBar.tsx">
import React from 'react';
import {useTheme} from '@mui/material/styles';
import Image from 'next/image';
import tumLogo from '../../../public/tum_logo_white.png';
import sam from '../../../public/sam.png';
import Typography from "@mui/material/Typography";
import {useMediaQuery} from "@mui/material";

const containerStyle: React.CSSProperties = {
    width: '40%',
    display: 'flex',
    justifyContent: 'center',
    flexDirection: 'column',
    alignItems: 'center',
};

const logoStyle: React.CSSProperties = {
    padding: '20%',
};

const bottomContainerStyle: React.CSSProperties = {
    width: '100%',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    padding: '0 5%',
    gap: '10px'
};

const textStyle: React.CSSProperties = {
    color: '#FFF',
    fontSize: '14px',
};

/**
 * TUM banner that is displayed in the starting screen.
 * @constructor
 */
const TumBar: React.FC = () => {
    const theme = useTheme();
    const isSmallScreen = useMediaQuery(theme.breakpoints.down('sm'));

    const dynamicTextStyle: React.CSSProperties = {
        ...textStyle,
        fontSize: isSmallScreen ? '10px' : '14px', // Adjust as needed
    };

    return (
        <div style={{...containerStyle, backgroundColor: theme.palette.secondary.main}}>
            <Image src={sam}
                   alt="Logo"
                   layout="intrinsic"
                   style={logoStyle}
                   width={700}
                   height={100}
            />
            <div style={bottomContainerStyle}>
                <div style={{maxWidth: '130px', width: '100%', flexShrink: 1}}>
                    <Image src={tumLogo} alt="TUM Logo" layout="responsive" width={130} height={100}
                           objectFit="contain"/>
                </div>
                <Typography style={dynamicTextStyle} variant="body2" component="div">
                    Powered by the<br/>
                    Chair for Human-Centered Technologies for Learning<br/>
                    Contact us: sam.ai.mentor@sot.tum.de
                </Typography>
            </div>
        </div>
    );
};

export default TumBar;
</file>

<file path="SelfPacedStudy-ui/src/components/upload/components/DropzoneArea.tsx">
import React, {DragEvent, useRef, useState} from 'react';
import Typography from '@mui/material/Typography';
import {useTheme} from '@mui/material/styles';
import UploadFileIcon from '@mui/icons-material/UploadFile';
import LinkTypography from '@/components/generic/LinkTypography';
import UploadedFile from '@/components/upload/components/UploadedFile';

interface DropzoneAreaProps {
    allowedFileTypes: string; // Allowed file extension for uploads.
    maxFileSize: number;
    files: File[]; // Represents the PDF files.
    onChange: (files: File[]) => void; // Called when something is uploaded.
    disabled: boolean; // Check if DropZoneArea is disabled or not.
    description?: string;
}

interface FileWithProgress {
    file: File;
    progress: number;
}

const dropzoneStyles: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    width: '80%',
    borderRadius: '5px',
    padding: '4% 7%',
    border: '1.5px dashed var(--divider, rgba(0, 0, 0, 0.07))',
    gap: '22.293px',
};

export const DropzoneArea: React.FC<DropzoneAreaProps> = (props) => {
    const [dragIsOver, setDragIsOver] = useState(false);
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [files, setFiles] = useState<FileWithProgress[]>([]);

    const theme = useTheme();

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const newFiles = Array.from(event.target.files ?? [])
            .filter(file => ['application/pdf', 'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'].includes(file.type))
            .map(file => ({ file, progress: 0 }));

        setFiles(prevFiles => {
            const combinedFiles = [...prevFiles, ...newFiles];
            props.onChange(combinedFiles.map(f => f.file));
            return combinedFiles;
        });
    };

    // Define the event handlers
    const handleDragOver = (event: DragEvent<HTMLDivElement>) => {
        event.preventDefault();
        setDragIsOver(true);
    };

    const handleDragLeave = (event: DragEvent<HTMLDivElement>) => {
        event.preventDefault();
        setDragIsOver(false);
    };

    const handleDrop = (event: DragEvent<HTMLDivElement>) => {
        if (props.disabled) {
            return;
        }

        event.preventDefault();
        setDragIsOver(false);

        // Fetch the files
        const droppedFiles = Array.from(event.dataTransfer.files)
            .filter(file => ['application/pdf', 'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'].includes(file.type))
            .map(file => ({file, progress: 0}));

        setFiles(prevFiles => {
            const combinedFiles = [...prevFiles, ...droppedFiles];
            props.onChange(combinedFiles.map(f => f.file));
            return combinedFiles;
        });
    };

    const handleClick = () => {
        if (!props.disabled) {
            //console.log("Inside not disabled!!");
            fileInputRef.current?.click();
        }
    };

    const handleDelete = (index: number) => {
        setFiles(files => {
            const newFiles = files.filter((_, i) => i !== index);
            props.onChange(newFiles.map(f => f.file)); // Notify the parent component
            return newFiles;
        });
    };

    return (
        <>
            <div
                onDragOver={props.disabled ? undefined : handleDragOver}
                onDragLeave={props.disabled ? undefined : handleDragLeave}
                onDrop={props.disabled ? undefined : handleDrop}
                style={{
                    ...dropzoneStyles,
                    backgroundColor: dragIsOver ? 'rgba(0, 0, 0, 0.03)' : 'white',
                }}
            >
                <input
                    type="file"
                    style={{display: 'none'}}
                    ref={fileInputRef}
                    accept={props.allowedFileTypes}
                    disabled={props.disabled}
                    onChange={handleFileChange}
                    multiple
                />
                <UploadFileIcon fontSize="large" color={props.disabled ? 'disabled' : 'primary'}/>
                <Typography>
                    <LinkTypography onClick={handleClick} text="Click to upload" disabled={props.disabled}/>
                    {' or drag and drop'}
                </Typography>
                <Typography variant='body2'
                                color="GrayText"> {`Allowed file types: pdf, (max. 50MB)`} </Typography>            
                {props.description && <Typography color="darkred"> {props.description}</Typography>}
            </div>
            {files.map((fileWithProgress, index) => (
                <UploadedFile
                    key={index}
                    fileName={fileWithProgress.file.name}
                    uploadProgress={fileWithProgress.progress}
                    onDelete={() => handleDelete(index)}
                />
            ))}
        </>
    );
}


// color="GrayText"> {`Allowed file types: ${props.allowedFileTypes}, (max. ${props.maxFileSize}MB)`} </Typography>
</file>

<file path="SelfPacedStudy-ui/src/components/upload/components/UploadedFile.tsx">
import {IconButton} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import Typhography from '@mui/material/Typography';
import Box from '@mui/material/Box';
import UploadFileIcon from '@mui/icons-material/UploadFile';

interface UploadedFileProps {
    fileName: string;
    onDelete: () => void;
    uploadProgress: number; // Add this line
}

const UploadedFile: React.FC<UploadedFileProps> = ({fileName, onDelete}) => {
    return (
        <Box sx={{boxShadow: 1, alignItems: 'center', width: '80%', borderRadius: '5px', padding: '10px'}}>
            <div style={{display: 'flex', alignItems: 'center', justifyContent: 'space-between', width: '100%'}}>
                <div style={{display: 'flex', alignItems: 'center', gap: '10px'}}>
                    <UploadFileIcon fontSize="medium" color='primary'/>
                    <Typhography>{fileName}</Typhography>
                </div>
                <div style={{display: 'flex', alignItems: 'center', gap: '10px'}}>
                    <IconButton onClick={onDelete}>
                        <DeleteIcon/>
                    </IconButton>
                </div>
            </div>
        </Box>
    );
}

export default UploadedFile;
</file>

<file path="SelfPacedStudy-ui/src/components/upload/components/UploadTextField.tsx">
import React, {useState} from 'react';
import {TextField} from '@mui/material';
import {useTheme} from '@mui/material/styles';

interface UploadTextFieldProps {
    value: string,
    disabled: boolean,
    onChange: (value: string) => void,
    setIsVideoUrlValid?: React.Dispatch<React.SetStateAction<boolean>>;
}

export const UploadTextField: React.FC<UploadTextFieldProps> = (props) => {
    const theme = useTheme();
    const [isValid, setIsValid] = useState(true);

    /**
     * For now, only allow valid youtube links.
     * @param event
     */
    const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const value = event.target.value;
        const youtubeUrlRegex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.?be)\/.+$/;
        const isValid = youtubeUrlRegex.test(value);
        setIsValid(isValid);

        if (props.setIsVideoUrlValid) {
            props.setIsVideoUrlValid(isValid);
        }

        props.onChange(value);
    }

    const textFieldStyles: React.CSSProperties = {
        width: '80%',
        borderRadius: '5px',
        borderColor: isValid ? theme.palette.primary.main : 'red',
    };

    return (
        <TextField
            variant="outlined"
            label="Upload via link (Only YouTube videos are supported)"
            style={textFieldStyles}
            color='primary'
            value={props.value}
            onChange={handleChange}
            disabled={props.disabled}
            error={!isValid}
        />
    );
};

export default UploadTextField;
</file>

<file path="SelfPacedStudy-ui/src/components/upload/Upload.tsx">
import React from 'react';
import {DropzoneArea} from '@/components/upload/components/DropzoneArea';
import {UploadTextField} from '@/components/upload/components/UploadTextField';
import TitleTypography from '@/components/generic/TitleTypography';

interface UploadProps {
    urlFlag: boolean; // Display the URL input field or not.
    dragzoneFlag: boolean; //Display the drag zone field or not.
    allowedFileTypes: string; // Allowed file extensions for upload.
    maxFileSize: number;
    title: string; //Title of the panel
    description?: string;
    url?: string; // URL that is entered in the input field.
    setUrl?: React.Dispatch<React.SetStateAction<string>>; // Called whenever user enters a URL.
    files: File[]; // Represents the lecture PDF's user can upload.
    setFiles: React.Dispatch<React.SetStateAction<File[]>>; // Called when user uploads files.
    setIsVideoUrlValid?: React.Dispatch<React.SetStateAction<boolean>>; // Video URL valid or not.
}

const containerStyle: React.CSSProperties = {
    margin: '0 0 5rem 0',
    width: '100%',
};

/**
 * Component to handle uploads. With parameters, it can handle both URL input and PDF input.
 * @param props
 * @constructor
 */
const Upload: React.FC<UploadProps> = (props) => {

    /**
     * Handles the event when the value inside the text field changes.
     * @param value - Current value of the text field.
     */
    const handleTextFieldChange = (value: string) => {
        if (props.urlFlag && props.setUrl) {
            props.setUrl(value); // Call setUrl only if it's provided
            props.setFiles([]); // Clear files when URL is set
        }
    };

    /**
     * Handles the event when the user uploads a file using drag and drop.
     * @param uploadedFiles - Files user uploded.
     */
    const handleDropzoneChange = (uploadedFiles: File[]) => {
        if (props.dragzoneFlag && props.setUrl) {
            props.setUrl(''); // Clear URL when files are uploaded, only if setUrl is provided
        }
        props.setFiles(uploadedFiles);
        props.setFiles(uploadedFiles);
    };

    return (
        <div style={containerStyle}>
            <TitleTypography text={props.title}/>
            <div>
                {props.urlFlag && (
                    <UploadTextField
                        value={props.url || ''}
                        onChange={handleTextFieldChange}
                        disabled={props.files.length > 0}
                        setIsVideoUrlValid={props.setIsVideoUrlValid}
                    />
                )}
                {props.dragzoneFlag && (
                    <div style={{marginTop: '1%'}}>
                        <DropzoneArea
                            allowedFileTypes={props.allowedFileTypes}
                            maxFileSize={props.maxFileSize}
                            files={props.files}
                            onChange={handleDropzoneChange}
                            disabled={!!(props.urlFlag && props.url && props.url.length > 0)}
                            description={props.description}
                        />
                    </div>
                )}
            </div>
        </div>
    );
};

export default Upload;
</file>

<file path="SelfPacedStudy-ui/src/components/video-player/VideoPlayer.tsx">
'use client';

import React, {useEffect, useRef, useState} from 'react';
import ReactPlayer from 'react-player';

interface VideoPlayerProps {
    url: string;
    isChatBoxOpen: boolean;
    setIsVideoManuallyPaused: (value: boolean) => void;
    isVideoManuallyPaused: boolean;
    setVideoPosition: (value: number) => void;
    setVideoDuration: (value: number) => void; // New prop for setting video duration
}

/**
*
    @param url - URL of the video that is being streamed.
    @param isChatBoxOpen - State of the ChatBox
    @param setIsVideoManuallyPaused - Call if the video is manually paused or paused because of the ChatBox.
    @param isVideoManuallyPaused - State of the function setIsVideoManuallyPaused.
    @param setVideoPosition - Record the video position.
    @param setVideoDuration - Record the video duration.
    @constructor
    */
const VideoPlayer: React.FC<VideoPlayerProps> = ({url, isChatBoxOpen, setIsVideoManuallyPaused, isVideoManuallyPaused, setVideoPosition, setVideoDuration}) => {
    const [hasWindow, setHasWindow] = useState(false);
    
    useEffect(() => {
        if (typeof window !== "undefined") {
            setHasWindow(true);
        }
    }, []);
    
    const videoPlayerRef = useRef<ReactPlayer>(null as any);

    /**
        Update the video position every 500ms.
    */
    useEffect(() => {
        const interval = setInterval(() => {
            if (videoPlayerRef.current) {
                setVideoPosition(videoPlayerRef.current.getCurrentTime());
            }
        }, 500);
        return () => clearInterval(interval);
    }, [setVideoPosition]);

    const handleOnPlay = () => {
        // The reason for these is that we don't want to start the video by opening the ChatBox if the user stopped it themselves.
        setIsVideoManuallyPaused(false);
    };

    const handleOnPause = () => {
        setIsVideoManuallyPaused(true);
    };

    const handleOnReady = () => {
        if (videoPlayerRef.current) {
            setVideoDuration(videoPlayerRef.current.getDuration());
        }
    };

    return (
        <>
            {hasWindow &&
                <ReactPlayer
                    ref={videoPlayerRef}
                    url={url}
                    className='react-player'
                    width='100%'
                    height='100%'
                    controls={true}
                    playing={!isChatBoxOpen && !isVideoManuallyPaused}
                    onPlay={handleOnPlay}
                    onPause={handleOnPause}
                    onReady={handleOnReady} // Set video duration when the player is ready
                />
            }
        </>
    );
};

export default VideoPlayer;
</file>

<file path="SelfPacedStudy-ui/src/theme/theme.tsx">
import { ThemeOptions } from '@mui/material/styles';
import '@fontsource/roboto';

export const themeOptions: ThemeOptions = {
  palette: {
    secondary: {
      main: '#0065bd',
      dark: '#005293',
      light: '#64a0c8'
    },
  },
  typography: {
    fontFamily: 'Roboto',
    fontWeightLight: 200,
    fontWeightRegular: 400,
    fontWeightMedium: 600,
    fontWeightBold: 800,
  },
  components: {
    MuiTypography: {
      defaultProps: {
        color: 'rgba(0, 0, 0, 0.8)',
        letterSpacing: '0.418px',
      }
    },
    MuiButton: {
      styleOverrides: {
          root: ({ theme }) => ({
              '&.MuiButton-containedPrimary': {
                  backgroundColor: theme.palette.secondary.main,
              },
              '&.MuiButton-containedPrimary:hover': {
                  backgroundColor: theme.palette.secondary.dark,
              }
          }),
      },
    }
  }
};
</file>

<file path="SelfPacedStudy-ui/src/utils/constants.tsx">
// Welcome message
export const WELCOME_MESSAGE = "Welcome to SAM (Study with AI Mentor)!";

// Ready to Learn message - first paragraph
export const READY_TO_LEARN_MESSAGE = `
  SAM is an innovative tool designed to transform your learning experience. Watch educational videos and interact with our AI mentor in real time. On the next page, you’ll find our experimental video—get ready to explore learning like never before!
`;
// Ready to Learn message - first paragraph
export const READY_TO_LEARN_INTRO = `
  SAM is an innovative tool designed to transform your learning experience. Watch educational videos and interact with our AI mentor in real time. On the next page, you’ll find our experimental video—get ready to explore learning like never before!
`;

// Key Features title
export const KEY_FEATURES_TITLE = "Key Features:";

// Key Features as an array of items (list items)
export const KEY_FEATURES = [
    "Real-time question-answering during video lectures",
    "Context-specific explanations of slides, formulas, and images",
    "Upload images for clarification if you don’t understand a figure or formula",
    "Download your entire chat for future reference and study"
];

// Ready to Learn message - final paragraph
export const READY_TO_LEARN_OUTRO = `
  Discover how SAM can help you take full ownership of your learning journey!
`;
export const INSTRUCTION_1 = "1. Open SAM in a new Google Chrome window. Enter the URL of your lecture video. Optional (but recommended): upload your slides or any PDF file that contains relevant information for the lecture to improve the LLM's performance.";
export const INSTRUCTION_2 = '2. Before watching your lecture, please fill out our pre-test by clicking on "FILL OUT THE QUESTIONNAIRE:". Test group: Please allow screen sharing to enhance user experience. Screen shots will be used to aswer questions corresponding to specific slides. While watching the video, if you have any questions, just ask! SAM, the bot, uses your current position in the video and your uploaded slides as additional context. For example, if the instructor is talking about an equation, try asking: "Explain this equation in more detail." You can also upload images. Just upload an image and ask about it, or use it to provide additional context.';
export const INSTRUCTION_3 = `3. After you finished with the lecture, you can download your chat at the top right corner. Please dont forget to fill out the remaining part of the questionnaire.`;
</file>

<file path="SelfPacedStudy-ui/src/utils/ParseLatex.tsx">
import React from 'react';
import {BlockMath, InlineMath} from 'react-katex';
import 'katex/dist/katex.min.css';

/**
 * Function to separate the Latex components and the text.
 * @param text - The input text that we want to parse. Can contain mathematical formulas in Tex notation.
 */
const parseLatex = (text: string) => {
    //console.log("TEXT ", text);
    const elements = [];
    let lastIndex = 0;

    // Regex to match inline (\(...\)) and block (\[...\] or $$...$$) LaTeX
    const latexRegex = /\\\((.*?)\\\)|(?:\$\$(.*?)\$\$)|(?:\\\[([\s\S]*?)\\\])/gs;
    let match;

    while ((match = latexRegex.exec(text)) !== null) {
        // Add the text before the LaTeX part
        if (match.index > lastIndex) {
            elements.push(text.slice(lastIndex, match.index));
        }

        // Extract the actual content depending on the type of LaTeX block
        let latexContent = '';
        let isBlock = false;

        if (match[1]) { // Inline math \(...\)
            //console.log("Match2: ", match[1]);
            latexContent = match[1];
        } else if (match[2]) { // Block math $$...$$
            latexContent = match[2];
            isBlock = true;
        } else if (match[3]) { // Block math \[...\]
            latexContent = match[3];
            //console.log("latex content 4");
            isBlock = true;
        }

        // Add LaTeX component
        elements.push(
            isBlock ? <BlockMath key={match.index} math={latexContent}/> :
                <InlineMath key={match.index} math={latexContent}/>
        );

        // Update lastIndex to the end of the current match
        lastIndex = match.index + match[0].length;
    }


    // Add any remaining text after the last LaTeX part
    if (lastIndex < text.length) {
        elements.push(text.slice(lastIndex));
    }
    //console.log(elements);
    return elements;
};

export default parseLatex;
</file>

<file path="SelfPacedStudy-ui/src/utils/UseOutsideClickDetectorHook.tsx">
import {RefObject, useEffect} from 'react';

/**
 * A hook to detect if the user is clicking outside of the ChatBox so we can close it.
 * @param ref - ChatBox reference.
 * @param onOutsideClick - Called when user clicked outside.
 * @param excludedRefs - References to some components that are outside of the ChatBox but should not close the ChatBox when clicked.
 */
const useOutsideClickDetector = (
    ref: RefObject<HTMLElement>,
    onOutsideClick: () => void,
    excludedRefs?: RefObject<HTMLElement>[] // Array of refs to be excluded
) => {
    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            const targetNode = event.target as Node;

            // Check if the click is outside ref and all excludedRefs
            const isOutside = ref.current && !ref.current.contains(targetNode) &&
                (!excludedRefs || excludedRefs.every(excludedRef =>
                    !excludedRef.current || !excludedRef.current.contains(targetNode)));

            if (isOutside) {
                onOutsideClick();
            }
        };

        document.addEventListener('mousedown', handleClickOutside);

        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [ref, onOutsideClick, excludedRefs]);
};

export default useOutsideClickDetector;
</file>

<file path="SelfPacedStudy-ui/.env.example">
NEXT_PUBLIC_BACKEND_URL="URL for your backend application"
</file>

<file path="SelfPacedStudy-ui/.eslintrc.json">
{
  "extends": "next/core-web-vitals"
}
</file>

<file path="SelfPacedStudy-ui/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

.idea

.env
</file>

<file path="SelfPacedStudy-ui/Dockerfile">
# Use an official Node.js runtime as a parent image
FROM node:18

# Set the working directory to /app
WORKDIR /app

# Copy the package.json and package-lock.json
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the application code
COPY . .

# Copy the .env file
COPY .env .env

# Build the application
RUN npm run build

# Expose the port the app runs on
EXPOSE 3000

CMD ["npm", "run", "start"]
#CMD ["npm", "run", "dev"]
</file>

<file path="SelfPacedStudy-ui/LICENSE">
MIT License

Copyright (c) 2024 SelfPacedStudy-Orga

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="SelfPacedStudy-ui/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = nextConfig
</file>

<file path="SelfPacedStudy-ui/package.json">
{
  "name": "selfpacedstudy-ui",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@emotion/react": "^11.11.3",
    "@emotion/styled": "^11.11.0",
    "@fontsource/roboto": "^5.0.8",
    "@mui/icons-material": "^5.15.5",
    "@mui/material": "^5.15.5",
    "html2canvas": "^1.4.1",
    "js-cookie": "^3.0.5",
    "katex": "^0.16.9",
    "next": "^14.2.26",
    "react": "^18",
    "react-dom": "^18",
    "react-katex": "^3.0.1",
    "react-player": "^2.14.1",
    "sharp": "^0.33.5",
    "use-react-screenshot": "^4.0.0",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@types/js-cookie": "^3.0.6",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/react-katex": "^3.0.4",
    "@types/uuid": "^9.0.8",
    "@typescript-eslint/eslint-plugin": "^6.19.0",
    "@typescript-eslint/parser": "^6.19.0",
    "autoprefixer": "^10.0.1",
    "eslint": "^8",
    "eslint-config-next": "14.0.4",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}
</file>

<file path="SelfPacedStudy-ui/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="SelfPacedStudy-ui/README.md">
# AI-Powered Real-Time Support Tool for Self-Paced Studying

## Overview

This application serves as the user interface for the SelfPacedStudy platform, offering real-time assistance and support
to
learners engaged in self-paced study through pre-recorded online lecture videos and accompanying slides. Our AI-powered
support tool, the Lecture Learning Model (LLM), acts as a chatbot, responding to user queries based on the lecture video
and slides provided. The LLM uses the lecture video and slides transcripts as context to provide more accurate answers
to your questions.
The SelfPacedStudy is designed to be simple and easy to use, so a user would not have any distractions when studying
via. this platform.
Developed for the Project Week at TUM.

## Getting Started

### Prerequisites

- npm

### Installation

This is a [Next.js](https://nextjs.org/) project bootstrapped
with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

1. Clone the repository: `git clone https://github.com/SelfPacedStudy-Orga/SelfPacedStudy-ui.git`
2. Navigate to the project directory: `cd SelfPacedStudy-ui`
3. Install the dependencies: `npm install`

### Configuration

Copy the `.env.example` file and rename it to `.env`. Fill in the necessary environment variables.

## Running the Application

To start the server in development mode, run: `npm run dev`

## Project Structure

The main codebase is located in the `/src` directory. Here’s a brief overview of each subdirectory:

- `/src/app`: This directory contains all the main app.tsx file that `next` uses to render the components.
  For `react-native` users, this is similar to a `pages` file.
- `/src/components`: This directory contains all the React components. 
- `/src/theme`: This directory contains the theme of the app.
- `/src/utils`: This directory contains the util functions. 

## Contributing

If you want to contribute to this project, please create a new branch, make your changes, and create a pull request.
</file>

<file path="SelfPacedStudy-ui/tailwind.config.ts">
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
}
export default config
</file>

<file path="SelfPacedStudy-ui/tsconfig.json">
{
  "compilerOptions": {
    "target": "es6",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
